{"meta":{"title":"Midsummer124的Blog","subtitle":"忘记了过去，迷失在未来","description":"cuit大学，目前freshman一枚","author":"Midsummer124","url":"http://Midsummer.github.io.com","root":"/"},"pages":[{"title":"","date":"2022-11-17T05:32:18.810Z","updated":"2022-11-17T05:26:17.684Z","comments":true,"path":"photos/生活剪影.html","permalink":"http://midsummer.github.io.com/photos/%E7%94%9F%E6%B4%BB%E5%89%AA%E5%BD%B1.html","excerpt":"","text":"故乡的风景 夜爬龙泉山的日出 学校的猫 校园风光"}],"posts":[{"title":"Ethernaut靶场","slug":"Ethernaut靶场","date":"2022-12-05T08:55:26.000Z","updated":"2022-12-05T08:55:26.028Z","comments":true,"path":"2022/12/05/Ethernaut靶场/","link":"","permalink":"http://midsummer.github.io.com/2022/12/05/Ethernaut%E9%9D%B6%E5%9C%BA/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"svip","slug":"svip","date":"2022-12-02T06:36:59.000Z","updated":"2022-12-05T08:54:39.899Z","comments":true,"path":"2022/12/02/svip/","link":"","permalink":"http://midsummer.github.io.com/2022/12/02/svip/","excerpt":"","text":"合约已部署 从 svip 合约可知，成为 svip 至少需要999 points，而我们一开始 numofree 只能为我们提供100 points. 合约地址: 0xb14a483BA2F59d5C34CB0e3C43f94ff2f486dEc5","categories":[],"tags":[{"name":"solidity","slug":"solidity","permalink":"http://midsummer.github.io.com/tags/solidity/"}]},{"title":"文件操作","slug":"文件操作","date":"2022-12-01T03:28:22.000Z","updated":"2022-12-05T08:58:36.415Z","comments":true,"path":"2022/12/01/文件操作/","link":"","permalink":"http://midsummer.github.io.com/2022/12/01/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"文件操作略学了一点","text":"文件操作略学了一点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980使用FILE *fp;来创建文件指针fopen(&quot;文件位置&quot;,&quot;打开方式&quot;);文件位置1. 绝对位置 全盘路径 2. 相对位置 同级目录 下级目录 上级目录打开方式1.&quot;r&quot; 只读 若不存在-报错 2.&quot;w&quot; 只写 若不存在-新建 3.&quot;a&quot; 追加 若不存在-新建 文件结束标记符 EOFchar ch;fp=fopen(&quot;cuit.txt&quot;,&quot;r&quot;);ch=fgetc(fp);fputc(ch,fp);fclose(fp);#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;/*function: 创建cuit2文件，读取cuit文件，将cuit复制到cuit2. */void main()&#123; FILE *fp1,*fp2; char ch; fp1=fopen(&quot;cuit2.txt&quot;,&quot;w&quot;); fp2=fopen(&quot;cuit.txt&quot;,&quot;r&quot;); ch=getc(fp2); while(ch!=EOF) &#123; fputc(ch,fp1); ch=getc(fp2); &#125; fclose(fp1);fclose(fp2); fp1=fopen(&quot;cuit2.txt&quot;,&quot;r&quot;); if(fp1==NULL) &#123; printf(&quot;failed&quot;); exit(0); &#125; ch=fgetc(fp1); while(ch!=EOF) &#123; putchar(ch); ch=fgetc(fp1); &#125; fclose(fp1);&#125;类似于scanf,和printf;功能几乎一样; int a;fscanf(文件指针,&quot;内容例如%d&quot;,&amp;a);fprintf(文件指针,&quot;内容%2d&quot;,a);fgets(字符数组地址,多少,文件指针);fseek(文件指针,偏移量,起始位置)若成功返回0起始位置SEEK_SET： 文件开头 --&gt;&gt; 1SEEK_CUR： 当前位置 --&gt;&gt; 2SEEK_END： 文件结尾 --&gt;&gt; 3","categories":[],"tags":[{"name":"c语言 文件操作","slug":"c语言-文件操作","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]},{"title":"传智杯练习","slug":"传智杯练习","date":"2022-11-26T06:58:45.000Z","updated":"2022-11-27T03:57:01.275Z","comments":true,"path":"2022/11/26/传智杯练习/","link":"","permalink":"http://midsummer.github.io.com/2022/11/26/%E4%BC%A0%E6%99%BA%E6%9D%AF%E7%BB%83%E4%B9%A0/","excerpt":"[传智杯 #5 练习赛] 时钟题目描述你有一个电子钟，可以显示 0:00 到 23:59 之间的所有时间，以数字的形式显示。其中小时是 0 到 23（0 时会显示一个 0，而 1 到 9 时不会显示前导 0），分钟是 00 到 59（0 到 9 分都会显示前导 0）。任何时刻，电子钟都会显示三个或者四个 $0$ 到 $9$ 的数字。如果在某时刻，这些数字依次组成了一个等差数列，则这个时刻被称为“好时刻”。 你感觉很无聊，从 0:00 时刻开始盯着这个电子钟。一共盯了 $x$ 分钟。请问整个过程中，”好时刻”来临了多少次（算上开头和结尾）？","text":"[传智杯 #5 练习赛] 时钟题目描述你有一个电子钟，可以显示 0:00 到 23:59 之间的所有时间，以数字的形式显示。其中小时是 0 到 23（0 时会显示一个 0，而 1 到 9 时不会显示前导 0），分钟是 00 到 59（0 到 9 分都会显示前导 0）。任何时刻，电子钟都会显示三个或者四个 $0$ 到 $9$ 的数字。如果在某时刻，这些数字依次组成了一个等差数列，则这个时刻被称为“好时刻”。 你感觉很无聊，从 0:00 时刻开始盯着这个电子钟。一共盯了 $x$ 分钟。请问整个过程中，”好时刻”来临了多少次（算上开头和结尾）？ 输入格式一个不超过 $10^9$ 的非负整数。 输出格式请输出”好时刻”来临了多少次？ 样例 #1样例输入 #11120 样例输出 #1110 样例 #2样例输入 #212880 样例输出 #2179 样例 #3样例输入 #31987654321 样例输出 #3126748975 提示【样例解释】 你观察了 2 个小时，其中这些“好时刻”来临了： 123456789100:000:120:240:360:481:111:231:351:471:59 一共是 10 个。 我的100分解答: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int judge(int a,int b)&#123; int t1,t2,t3,t4; if(a&lt;=9) &#123; t1=0; t2=a; t4=b%10; t3=(b-t4)/10; if(t3-t2==t4-t3) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; else &#123; t2=a%10; t1=(a-t2)/10; t4=b%10; t3=(b-t4)/10; if(t2-t1==t3-t2&amp;&amp;t3-t2==t4-t3&amp;&amp;t2-t1==t4-t3) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125;int main()&#123; int a,b,i,j,x,goodmoment=0,k=0; scanf(&quot;%d&quot;,&amp;x);j=x; if(x&gt;1440) &#123; while(j&gt;1440) &#123; j-=1440; k++; &#125; if(j==1440) &#123; goodmoment+=1; &#125; &#125; for(a=0,b=0;a*60+b&lt;=j;b++) &#123; if(judge(a,b)) &#123; goodmoment++; &#125; if(a==23&amp;&amp;b==59) &#123; break; &#125; if(b==59) &#123; a++; b=0; continue; &#125; &#125; if(k&gt;=1) &#123; printf(&quot;%d&quot;,goodmoment+39*k); &#125; else &#123; printf(&quot;%d&quot;,goodmoment); &#125;&#125; [传智杯 #5 练习赛] 平等的交易题目描述你有 $n$ 件道具可以买，其中第 $i$ 件的价格为 $a_i$。 你有 $w$ 元钱。你仅能用钱购买其中的一件商道具。当然，你可以拿你手中的道具换取其他的道具，只是这些商道具的价值之和，不能超过你打算交换出去的道具。你可以交换无数多次道具。道具的价值可能是 $0$，但是你不能使用空集换取价值为 0 的商品。 请问，在这个条件下，最多可以换取多少件道具？ 输入格式第一行一个正整数 $n$，表示道具个数。 接下来一行 $n$ 个正整数，表示 ${a_n}$。 接下来一行 $1$ 个正整数，表示 $w$。 输出格式一个正整数，表示答案。 样例 #1样例输入 #11233 1 1 25 样例输出 #112 提示【样例解释】 买价值为 $2$ 的道具，并交换为两个价值为 $1$ 的道具。 【数据范围及约束】 测试数据满足，$1 \\leq n\\leq10^6$，$0 \\leq a_i\\leq 10^9$，$1 \\leq w\\leq2\\times10^{9}$。 我的70分解答: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int func(int mip[],int n,int m)&#123; int i; for(i=n-1;i&gt;=0;i--) &#123; if(m&gt;=mip[i]) &#123; return mip[i]; &#125; &#125;&#125;int main()&#123; int n,i,m,cou=0,t,j; // m for money scanf(&quot;%d&quot;,&amp;n); int ip[n],mip[n]; //item price for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;ip[i]); mip[i]=ip[i]; &#125; scanf(&quot;%d&quot;,&amp;m); for(i=0;i&lt;n;i++) for(j=0;j&lt;n-i-1;j++) &#123; if(mip[j]&gt;mip[j+1]) &#123; t=mip[j];mip[j]=mip[j+1];mip[j+1]=t; &#125; &#125; int max=func(mip,n,m); for(i=0;i&lt;n;i++) &#123; if(mip[i]&lt;=max) &#123; cou++; max-=mip[i]; &#125; &#125; printf(&quot;%d&quot;,cou); return 0;&#125; [传智杯 #5 练习赛] 复读题目描述给定若干个字符串，不定数量，每行一个。有些字符串可能出现了多次。如果读入一个字符串后，发现这个字符串以前被读入过，则这个字符串被称为前面相同的字符串的复读，这个字符串被称为复读字符串。相应的，每个首次出现的字符串就是非复读字符串。 举个例子， 12345abcdefabcabcabc 第 $1,3,4,5$ 行是字符串 abc，那么 $3,4,5$ 行的字符串会被称为“复读”。 请你把所有的非复读字符串，按照行号从小到大的顺序，依次拼接为一个长串并输出。 输入格式多个字符串，每行一个，含义见题目描述。 注意：如果这个字符串是 0，说明所有字符串都读完了。这个 0 不认为是一个“非复读字符串”。 输出格式共一行，表示所有非复读字符串，按照行号从小到大依次连接的结果。 样例 #1样例输入 #112345ccbacc0 样例输出 #11ccba 提示【数据范围】 字符串的个数不超过 $500$ 个，字符串总长度不超过 $50000$，每个字符串中只包含小写字母、数字、 . 、! 和 &amp;，不包含空格等特殊符号。 [传智杯 #5 练习赛] 清洁工题目描述有一个 $n\\times n$ 的地块，一个连续 $i$ 分钟没人经过的地面在第 $i$ 分钟会落上 $i$ 个单位的灰，有人经过时不会落灰但灰也不会清零，在人走后第一分钟又会落上一个单位的灰，以此类推。你在这个 $n\\times n$ 的范围内移动，你的移动轨迹可以描述为一个由 $\\text{N,S,W,E}$ 组成的字符串，每个字母分别表示上、下、左、右。这个人一开始在点 $(x,y)$，每一分钟移动一步。 求最后每一个位置上落下的灰的量。 本题中的上和右分别表示 $y$ 轴正方向和 $x$ 轴正方向。保证你没有超过移动的范围。 输入格式第一行四个正整数 $n,m,x,y$，含义如题面所示，其中 $x,y$ 表示横纵坐标，不是数组下标。第二行一个长度为 $m$ 的字符串，表示你的移动序列。 输出格式共$n$ 行，每行 $n$ 个数，第 $i$ 行的第 $j$ 个数表示坐标 $(j,n-i+1)$ 上的灰的数量 样例 #1样例输入 #1125 4 1 1NENW 样例输出 #11234510 10 10 10 10 10 10 10 10 10 10 6 10 10 10 4 4 10 10 10 6 10 10 10 10 样例 #2样例输入 #2127 14 1 1NENENENENESSSS 样例输出 #21234567105 105 105 105 105 105 105 105 105 105 105 55 61 105 105 105 105 49 51 69 105 105 105 51 49 105 79 105 105 61 55 105 105 91 105 79 69 105 105 105 105 105 91 105 105 105 105 105 105 样例 #3样例输入 #31210 70 2 2NWSNSNNNSNNSSNNSENNNNEESNWSESESSWENNSEWESWWWESEEESENNSENWNESNWSNNNEESS 样例输出 #3123456789102485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 1407 1205 1267 2485 2485 2485 2485 2485 2485 2485 1435 1281 1167 2485 2485 2485 2217 2281 2347 2485 1465 2485 1255 1041 2485 2485 2155 2485 2415 1557 1497 2485 2485 969 1177 2485 1733 1807 2485 1471 1531 1315 907 935 1267 2485 1473 1647 2485 1631 2485 2485 1357 1381 1407 1435 1499 1645 2485 2021 2347 2485 2485 2485 2485 1465 1497 2485 2485 2087 2415 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 样例 #4样例输入 #4125 4 2 1NENW 样例输出 #41234510 10 10 10 10 10 10 10 10 10 10 10 6 10 10 10 4 4 10 10 10 6 10 10 10 提示本题 y 轴朝上，x 轴朝右，样例输出中的左下角表示 $(1,1)$，第一分钟你在初始点处，第二分钟移动到相应的位置，第 $m+1$ 分钟移动到最后一个点，但是总共只有 $m$ 分钟，因此最后一个点不受移动的影响 样例 1 解释： 你的移动路径为 $(1,1)\\rightarrow(1,2)\\rightarrow(2,2)\\rightarrow(2,3)\\rightarrow(1,3)$，共 $4$ 分钟。 对于第 $1$ 分钟，$(1,1)$ 灰层数不变，其余点被落下了 $1$ 层灰。 对于第 $2$ 分钟，$(1,2)$ 灰层数不变，$(1,1)$ 被落下了 $1$ 层灰，其余点落下 $2$ 层灰。 对于第 $3$ 分钟，$(2,2)$ 灰层数不变，$(1,1)$ 落下 $2$ 层灰，$(1,2)$ 落下 $1$ 层灰，其余点落下 $3$ 层灰。 对于第 $4$ 分钟，$(2,3)$ 灰层数不变，$(1,1)$ 落下 $3$ 层灰，$(1,2)$ 落下 $2$ 层灰，$(2,2)$ 落下 $1$ 层灰，其余点落下 $4$ 层灰。 注意最后你移动到了 $(1,3)$，但是时间只有 $4$ 分钟，所以实际上不会对 $(1,3)$ 造成影响。初始点不一定在 $(1,1)$。 $1\\le n\\leq 50,1\\leq m\\le 1000$。 半成品: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;#define N 50int k=0,l=0;void ini(int re[][N],int n)&#123; int i,j; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; re[i][j]=0; &#125; &#125;&#125;void move(int *p1, int *p2, int re[][N], char ch, int n)&#123; int i,j,t=*(re[*p1]+*p2); if(k==0) &#123; ini(re,n); k++; &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; *(re[i]+j)+=1; &#125; &#125;// printf(&quot;re:\\n&quot;);// for(i=0;i&lt;n;i++)// &#123;// for(j=0;j&lt;n;j++)// &#123;// printf(&quot;%d &quot;,re[i][j]);// &#125;// putchar(&#x27;\\n&#x27;);// &#125; *(re[*p1]+*p2)=t;// switch(ch)// &#123;// case &#x27;N&#x27;:*p2+=1;break; // case &#x27;S&#x27;:*p2-=1;break; // case &#x27;W&#x27;:*p1-=1;break;// case &#x27;E&#x27;:*p1+=1;break; // default:break;// &#125;// printf(&quot;%d,%d\\n&quot;,*p1,*p2);&#125;void dust(int re[][N], int n, int sq[][N]) //积 灰 &#123; if(l==0) &#123; ini(sq,n); l++; &#125; int i,j; for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) *(sq[i]+j)+=*(re[i]+j);// printf(&quot;sq:\\n&quot;);// for(i=0;i&lt;n;i++)// &#123;// for(j=0;j&lt;n;j++)// &#123;// printf(&quot;%d &quot;,sq[i][j]);// &#125;// putchar(&#x27;\\n&#x27;);// &#125;&#125;int main()&#123; int n,m,x,y,i,j; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;x,&amp;y); x-=1;y-=1; int *p1,*p2;p1=&amp;x;p2=&amp;y; int sq[n][n],re[n][n]; char ch[1000]; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; re[i][j]=0;sq[i][j]=0; &#125; &#125; getchar(); gets(ch); for(i=0;i&lt;m;i++) &#123; move(p1,p2,re,ch[i],n); dust(re,n,sq); switch(ch[i]) &#123; case &#x27;N&#x27;:*p2+=1;break; case &#x27;S&#x27;:*p2-=1;break; case &#x27;W&#x27;:*p1-=1;break; case &#x27;E&#x27;:*p1+=1;break; default:break; &#125; re[*p1][*p2]=0; &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; printf(&quot;%d &quot;,sq[i][j]); &#125; putchar(&#x27;\\n&#x27;); &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; printf(&quot;%d &quot;,re[i][j]); &#125; putchar(&#x27;\\n&#x27;); &#125; return 0;&#125; [传智杯 #5 练习赛] 树的变迁题目描述给定一棵具有 $n$ 个节点的树，每个节点有一个初始权值 $a_i$。 一共需要进行 $m$ 次操作，每次操作包括： 1 e 编号为 $e$ 的边突然消失，使得它所在的那棵树变成了两棵树。 2 u val 编号为 $u$ 的节点的权值变成了 $val$。 3 u 进行了一次查询，查询 $u$ 所在的那棵树的权值之和。 现在你需要来模拟上述事件，以了解树的变迁。 输入格式第一行为 $n, m$，如上所述。 第二行有 $n$ 个数，为 $n$ 个结点的初始权值，在 $10^3$ 以内。 下面 $n-1$ 行，每行一组 $u, v$，表示一条边。（保证初始为一棵树） 下面 $m$ 行有 $m$ 个操作： 先读入一个 $\\text{opt}$，表示操作类型。 $\\text{opt}&#x3D;1$ 时，读入 $e$，表示删掉读入的第 $e$ 条边。（保证第 $e$ 条边存在） $\\text{opt}&#x3D;2$ 时，读入 $u,val$，表示把结点 $u$ 的权值改成 $val$（$val \\le 1000$）。 $\\text{opt}&#x3D;3$ 时，读入 $u$，表示查询 $u$ 所在的那棵树的结点权值和。 输出格式对于每个查询操作，输出一行一个数表示答案。 样例 #1样例输入 #11234562 31 11 22 2 41 13 2 样例输出 #114 提示所有测试数据数据满足 $1 \\leq n,m \\leq {10}^5$，$1 \\leq a_i,val \\leq 1000$。 [传智杯 #5 练习赛] 白色旅人题目描述有一个物品队列 $\\frak B$，初始时为空。现在共有三种操作。每个操作会给定三个整数 $\\mathrm{op},x,y$，其中 $\\mathrm{op}$ 表示操作种类，$x,y$ 是操作的参数。操作分为如下三种： $1$：向 $\\frak B$ 尾部添加一个物品，它的体积为 $x$，价值为 $y$。 $2$：把 $\\frak B$ 尾部最后物品移除。保证此时最少有一个物品。 $3$：有一个体积为 $x$ 的背包。用 $\\frak B$ 内的物品填充它，每个物品最多用一次，询问最多能获得多大的价值。提示：当 $\\frak B$ 为空时，相当于没有物品可用，答案就是 $0$。 对于操作 $2$ 和 $3$，请忽略多余的参数。 本题强制在线。强制在线的方式请见输入格式。 输入格式 第一行有两个正整数 $n,m_{\\max}$，表示操作个数以及操作 $3$ 提到的背包的体积的最大值。 接下来 $n$ 行，每行给定三个整数 $\\mathrm{op},x’,y’$。将 $x’,y’$ 分别异或上 $\\mathrm{lastans}$ 得到该次询问真正的 $x,y$。其中，$\\mathrm{lastans}$ 是上一次操作 $3$ 询问的结果。在第一次操作 $3$ 前，$\\mathrm{lastans}&#x3D;0$。 输出格式 输出有若干行，表示每次 $3$ 操作的结果。 样例 #1样例输入 #1123456789101110 101 3 41 5 53 4 13 12 51 14 33 1 82 11 113 2 112 8 83 12 8 样例输出 #112345491094 提示样例解释解码后的输入数据为： 123456789101110 101 3 41 5 53 4 13 8 11 7 103 8 12 1 13 8 12 1 13 5 1 对于十次操作，物品序列的情况如下； 加入体积为 $3$，价值为 $4$ 的物品。物品序列为 ${(3,4)}$。 加入体积为 $5$，价值为 $5$ 的物品。物品序列为 ${(3,4),(5,5)}$。 查询体积为 $4$ 的背包能装下的物品价值最大值。此时只能装第一个物品，于是答案为 $4$。 查询体积为 $8$ 的背包能装下的物品价值最大值。此时可把两个物品都装下，答案为 $9$。 加入体积为 $7$，价值为 $10$ 的物品。物品序列为 ${(3,4),(5,5),(7,10)}$。 查询体积为 $8$ 的背包能装下的物品价值最大值。此时直接装第三个物品获得的价值大于装下另外两个，于是答案为 $10$。 删除最后一个物品。此时物品序列为 ${(3,4),(5,5)}$。 查询体积为 $8$ 的背包能装下的物品价值最大值。此时可把两个物品都装下，答案为 $9$。 删除最后一个物品。此时物品序列为 ${(3,4)}$。 查询体积为 $5$ 的背包能装下的物品价值最大值。此时只有一个物品可装，答案为 $4$。 数据范围及约定对于全部数据，$1\\le n\\le 3\\times 10^4$，$1\\le m_{\\max}\\le 2\\times 10^4$，$1\\le x, y\\le 2\\times 10^4$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;//半成品typedef struct item&#123; int p; int v;&#125;it;it bag[2000];int time=0,lastans=0; //lastans为上次询问的结果 time 为背包位置指针 int *t=&amp;time,*la=&amp;lastans;it *pv; //我有的东西 void func(int move,int x,int y)&#123; if(move==1) &#123; *(pv+*t).p=x; *(pv+*t).v=y; &#125; else if(move==2) &#123; *(pv+*t).p=-1; //清空背包位置换为-1 *(pv+*t).v=-1; *t=*t-1; &#125; else if(move==3) &#123; fill_bag(x); &#125;&#125;void fill_bag(int x)&#123; s_max()&#125;int m_max;void main()&#123; int n; scanf(&quot;%d%d&quot;,&amp;n,&amp;m_max); int x,y,i,j,move; pv=(it*)malloc(sizeof(it)*n); for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d %d %d&quot;,move,x,y); func(move,x^(*la),y^(*la)); &#125;&#125;","categories":[],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"结构体和链表","slug":"结构体和链表","date":"2022-11-24T13:29:05.000Z","updated":"2022-11-25T04:19:38.975Z","comments":true,"path":"2022/11/24/结构体和链表/","link":"","permalink":"http://midsummer.github.io.com/2022/11/24/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E9%93%BE%E8%A1%A8/","excerpt":"1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;struct student&#123; char name; int age; struct student *next;&#125;;void main()&#123; typedef struct student stu; stu *head,a,b,c,d,*p; head=&amp;a; a.next=&amp;b; b.next=&amp;c; c.next=&amp;d; d.next=NULL; p=head; a.age=20; a.name=&#x27;c&#x27;; b.age=18; b.name=&#x27;g&#x27;; c.age=16; c.name=&#x27;m&#x27;; d.age=70; d.name=&#x27;f&#x27;; while(p!=NULL) &#123; printf(&quot;%c\\n&quot;,p-&gt;name); printf(&quot;%d\\n&quot;,p-&gt;age); p=p-&gt;next; &#125;&#125;","text":"1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;struct student&#123; char name; int age; struct student *next;&#125;;void main()&#123; typedef struct student stu; stu *head,a,b,c,d,*p; head=&amp;a; a.next=&amp;b; b.next=&amp;c; c.next=&amp;d; d.next=NULL; p=head; a.age=20; a.name=&#x27;c&#x27;; b.age=18; b.name=&#x27;g&#x27;; c.age=16; c.name=&#x27;m&#x27;; d.age=70; d.name=&#x27;f&#x27;; while(p!=NULL) &#123; printf(&quot;%c\\n&quot;,p-&gt;name); printf(&quot;%d\\n&quot;,p-&gt;age); p=p-&gt;next; &#125;&#125; Notes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138结构体的一般定义 struct STU //定义类型 &#123; char num[11]; 并非真的定义变量 char name[20]; char sex[3]; float totalscore; float avgscore;&#125;;初始化struct STU student1,studen2; 系统会自动给这2个人加分配内存紧凑版struct STU &#123; char num[11]; 并非真的定义变量 char name[20]; char sex[3]; float totalscore; float avgscore;&#125;student1,student2;录入数据 struct STU sudent1=&#123;&quot;2018231048&quot;,&quot;李四&quot;,等等&#125;;student1.num=190631scanf(&quot;%s&quot;,student1.num) 不需要加&amp;，已经是地址 若成员学籍号定义为char num[11]则用 strcpy(student1.num,&quot;2023123123&quot;)或gets(student1.num) struct STU *p;指针访问成员p-&gt;name;p-&gt;age;p-&gt;sex; 为指针分配空间 p=(struct STU *)malloc(sizeof(struct STU)*1);scanf(&quot;%s&quot;,p-&gt;name); 结构体中是数组 不用加&amp; scanf(&quot;%f&quot;,&amp;p-&gt;totalscore); 单个数值 要加&amp; int n;scanf(&quot;%d&quot;,&amp;n);struct STU *s1; 指针一条龙 s1=(struct STU)malloc(sizeof(struct STU)*n);for(i=0;i&lt;*n;i++)&#123;scanf(&quot;%d&quot;,&amp;(s1+i)-&gt;name);&#125;嵌套结构体 struct date&#123; int year; int month; int day;&#125;;struct STU &#123; struct date birthday; char num[11]; char name[20]; char sex[3]; float totalscore; float avgscore;&#125;student1,student2;student1.date.year=1998自定义名字 typedef struct student&#123; ..... &#125;stu;可直接使用stu 代表struct student; 结构体 传参 typedef struct student&#123; char name[10]; int weight;&#125;stu;void printstu(stu *studen_1)&#123; printf(&quot;name:%s weight:%d&quot;,studen_1.name,*student_1.weight);&#125;int sum_stu(stu studen_1)&#123; &#125;结构体的 swap stu p1,p2,t;t=p1;p1=p2;p2=t; 共用体union position&#123; int i; int j; char s[20];&#125;p1;成员是共享一个内存空间 =&gt; 同一时刻，一个变量起作用 int p1.i=10;int p1.j=20; p1.i被覆盖 strcpy(p1.s,&quot;fuck&quot;); p1.j被覆盖 最后只有p1.s存在 typedef struct person&#123; int grade; union &#123; char class[20]; char name; &#125;&#125;per;per per1;per1.grade=1;per1.name=george;","categories":[],"tags":[{"name":"c语言 结构体 链表","slug":"c语言-结构体-链表","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E7%BB%93%E6%9E%84%E4%BD%93-%E9%93%BE%E8%A1%A8/"}]},{"title":"c语言错误收集","slug":"c语言错误收集","date":"2022-11-21T07:44:34.000Z","updated":"2022-12-04T12:55:45.615Z","comments":true,"path":"2022/11/21/c语言错误收集/","link":"","permalink":"http://midsummer.github.io.com/2022/11/21/c%E8%AF%AD%E8%A8%80%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/","excerpt":"scanf 和 gets 连用的异常123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int m; scanf(&quot;%d&quot;,&amp;m); char ch[999]; gets(ch); puts(ch); printf(&quot;%d&quot;,m); return 0;&#125; 以上代码，gets运行异常，而去掉scanf，gets正常运行","text":"scanf 和 gets 连用的异常123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int m; scanf(&quot;%d&quot;,&amp;m); char ch[999]; gets(ch); puts(ch); printf(&quot;%d&quot;,m); return 0;&#125; 以上代码，gets运行异常，而去掉scanf，gets正常运行 分析: 实际上我们在输入的时候并非只输入了“值”，除了这个整数以外，我们还输入了一个“回车”。是的，回车是scanf结束输入的标志，但回车却不会被scanf接收。这个回车虽然被输入了，但却游离在函数之外，直到gets函数出现了。 是的，gets函数直接接受了“回车”。更要命的是，gets函数也是以回车为输入结束的，这就导致gets函数出现了明显的异常。 解决方案: 在scanf和gets之间加入一个getchar来吸收这个回车就行了。 使用字符的库函数若是数组 12char a[10];strlen(a); //使用常量地址即可 若是指针 123char *p;p=(char *)malloc(sizeof(char)*10);strlen(p); //切记不能加*,取其首地址即可 以上使用错误会致使段错误，使得程序无法正常运行. memset使用实例 1234567void *memset(void *s, int c, size_t n); //原函数//整型之类的int a[4];memset(a,1,sizeof(a));//使a的全部元素全变为&#x27;1&#x27;//字符型类char a[20];memset(a,&#x27;o&#x27;,sizeof(a)); 二维数组传参123456789//有以下几种形式 #define N 20 void func(int (*a)[N])//N必须为 明确数字 第一维可省略 void func(int a[][N])//使用二维数组 *(*(a+i)+j) //i为行j为列 *(a[i]+j) *((int *)a+i*n+j)//此为万金油 结构体录入数据1234567typedef struct book&#123; char name[20]; float price;&#125;bk;bk bo[10];scanf(&quot;%f&quot;,&amp;bo[0].price);//必须加取地址符&amp; 而%s不用就很迷 自定义函数内结构体指针访问结构体数组1234567891011121314typedef struct student stu;struct student fun(struct student *std, char *num)&#123; int i; for(i=0;i&lt;8;i++,*std++) &#123; if(std-&gt;num[0]==*num) &#123; return *std; &#125; &#125; stu p=&#123;&quot;0&quot;,0,0&#125;; return p;&#125; 动态链表原函数特定结点删除，新增特定元素的结点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode &#123; int data; struct ListNode *next;&#125;;typedef struct ListNode ln;struct ListNode *readlist()//创建 &#123; ln *head=NULL,*p1,*p2; int n=0; p1=p2=(ln*)malloc(sizeof(ln)); scanf(&quot;%d&quot;,&amp;p1-&gt;data); while(p1-&gt;data!=-1) &#123; n++; if(n==1) head=p1; else p2-&gt;next=p1; p2=p1; p1=(ln*)malloc(sizeof(ln)); scanf(&quot;%d&quot;,&amp;p1-&gt;data); &#125; p2-&gt;next=NULL; return head;&#125;struct ListNode *getodd( struct ListNode **L )&#123; ln *head=NULL,*p1,*p2,*p3,*p4; int n=0,i; p2=p3=(ln*)malloc(sizeof(ln)); for(p1=*L,i=0;p1!=NULL;p1=p1-&gt;next,i++) &#123; if(p1-&gt;data%2!=0)//将奇数录入新链表 &#123; n++; if(n==1) head=p2; else p3-&gt;next=p2; p2-&gt;data=p1-&gt;data; p3=p2; p2=(ln*)malloc(sizeof(ln)); &#125; if(p1-&gt;data%2!=0)//删除旧链表的奇数 &#123; if(i==0) &#123; *L=p1-&gt;next;i--;//i--尤为重要 &#125; else &#123; p4-&gt;next=p1-&gt;next; &#125; &#125; p4=p1;// printf(&quot;%d\\n&quot;,p1-&gt;data); &#125; p3-&gt;next=NULL; return head;&#125;void printlist( struct ListNode *L )&#123; struct ListNode *p = L; while (p) &#123; printf(&quot;%d &quot;, p-&gt;data); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; struct ListNode *L, *Odd; L = readlist(); Odd = getodd(&amp;L); printlist(Odd); printlist(L); return 0;&#125; 自定义函数动态链表结构体内元素的数组访问12345678910typedef struct student&#123; int num[20]; struct student *next;&#125;stu;stu* fun()&#123; stu p; &#125; 动态链表判断结束细节12345678910111213141516struct stud_node &#123; int num; char name[20]; int score; struct stud_node *next;&#125;;输入/*1 zhang 782 wang 803 li 754 zhao 850*/可以看到以num为0为特定动态链表结束的判断 1234567891011121314151617181920212223typedef struct stud_node stu;struct stud_node *createlist()&#123; stu *head=NULL,*p1,*p2; p1=p2=(stu*)malloc(sizeof(stu)); int n=0; scanf(&quot;%d&quot;,&amp;p1-&gt;num);//细节 if(p1-&gt;num==0) return NULL;//细节 scanf(&quot;%s%d&quot;,p1-&gt;name,&amp;p1-&gt;score); while(p1-&gt;num!=0) &#123; n++; if(n==1) head=p1; else p2-&gt;next=p1; p2=p1; p1=(stu*)malloc(sizeof(stu)); scanf(&quot;%d&quot;,&amp;p1-&gt;num);//细节 if(p1-&gt;num==0)break;//细节 scanf(&quot;%s%d&quot;,p1-&gt;name,&amp;p1-&gt;score); &#125; p2-&gt;next=NULL; return head;&#125; fgets123//原型#include &lt;stdio.h&gt;char *fgets(char *s, int size, FILE *stream); fgets()有三个参数。它的功能是从 stream 流中读取 size 个字符存储到字符指针变量 s 所指向的内存空间。它的返回值是一个指针，指向字符串中第一个字符的地址。 s 代表要保存到的内存空间的首地址，可以是字符数组名，也可以是指向字符数组的字符指针变量名。size 代表的是读取字符串的长度。stream 表示从何种流中读取，可以是标准输入流 stdin，也可以是文件流. fputs123//原型#include &lt;stdio.h&gt;int fputs(const char *s, FILE *stream); s 代表要输出的字符串的首地址，可以是字符数组名或字符指针变量名。 stream 表示向何种流中输出，可以是标准输出流 stdout，也可以是文件流。标准输出流即屏幕输出，printf 其实也是向标准输出流中输出的。 fputs() 和 puts() 有两个小区别：1.puts() 只能向标准输出流输出，而 fputs() 可以向任何流输出。2.使用 puts() 时，系统会在自动在其后添加换行符；而使用 fputs() 时，系统不会自动添加换行符。 那么这是不是意味着使用 fputs() 时就要在后面添加一句“printf(“\\n”)；”换行呢？看情况！如果输入时使用的是 gets()，那么就要添加 printf 换行；但如果输入时用的是 fgets()，则不需要。","categories":[],"tags":[{"name":"c语言 error","slug":"c语言-error","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-error/"}]},{"title":"蓝桥杯","slug":"蓝桥杯","date":"2022-11-19T09:29:49.000Z","updated":"2022-11-26T07:00:17.422Z","comments":true,"path":"2022/11/19/蓝桥杯/","link":"","permalink":"http://midsummer.github.io.com/2022/11/19/%E8%93%9D%E6%A1%A5%E6%9D%AF/","excerpt":"","text":"","categories":[],"tags":[{"name":"c语言 竞赛","slug":"c语言-竞赛","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E7%AB%9E%E8%B5%9B/"}]},{"title":"pointers","slug":"pointers","date":"2022-11-17T03:46:18.000Z","updated":"2022-11-20T08:08:27.793Z","comments":true,"path":"2022/11/17/pointers/","link":"","permalink":"http://midsummer.github.io.com/2022/11/17/pointers/","excerpt":"##字符串的排序 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; int n,i,j; scanf(&quot;%d&quot;,&amp;n); char *p[n+1],t[80]; for(i=0;i&lt;n+1;i++) &#123; p[i]=(char*)malloc(sizeof(char)*80); gets(p[i]); &#125; for(i=0;i&lt;n+1;i++) for(j=i+1;j&lt;n+1;j++) if(strcmp(p[i],p[j])&lt;0) &#123; strcpy(t,p[i]); strcpy(p[i],p[j]); strcpy(p[j],t); &#125; putchar(&#x27;\\n&#x27;); for(i=0;i&lt;n+1;i++) puts(p[i]); return 0;&#125;","text":"##字符串的排序 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; int n,i,j; scanf(&quot;%d&quot;,&amp;n); char *p[n+1],t[80]; for(i=0;i&lt;n+1;i++) &#123; p[i]=(char*)malloc(sizeof(char)*80); gets(p[i]); &#125; for(i=0;i&lt;n+1;i++) for(j=i+1;j&lt;n+1;j++) if(strcmp(p[i],p[j])&lt;0) &#123; strcpy(t,p[i]); strcpy(p[i],p[j]); strcpy(p[j],t); &#125; putchar(&#x27;\\n&#x27;); for(i=0;i&lt;n+1;i++) puts(p[i]); return 0;&#125; ##Notes 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394注意printf(&quot;%s&quot;,*p) p为一个指针 p=str (int str[4]) 使p指针指向str*(p+i)=score 使str[i]值==score int *p,a[10],i; p=a;*(p+i) = a[i] = *(a+i)p : 代表指向值的地址 *p: 代表指向的值 -----改变可直接改变指向的值 &amp;p: 代表指针的地址 int a[10]p不动遍历数组for(i=0;i&lt;10;i++) printf(&quot;%d&quot;,*(p+i));p移动遍历数组for(p=a;p&lt;a+10;p++) printf(&quot;%d&quot;,*p); // p指针用完要复位 指针和二维数组int a[3][3] int *p;p=a;*a: 数组首地址0行0列*(a+1): 第1行0列的 **地址** *a+1: 第0行1列 **地址** *(a+2)+2: 第2行2列 **地址** -----i行j列的 **地址** = *(a+i)+j i行j列的值 = *(*(a+i)+j) 分配空间int *p;int i;p=(int *)malloc(sizeof(int)*10); // 申请10个int内存 for(i=0;i&lt;10;i++)&#123; scanf(&quot;%d&quot;,p+i);&#125;for(i=0;i&lt;10;i++)&#123; printf(&quot;%d&quot;,*(p+i))&#125;注意 以下p是函数名 返回指针的函数&#123; int *p(int a,int b) 指向什么类型的指针前缀用什么类型； return 指针; &#125;指向函数的指针&#123; 初始 int(*p)(int a,int b) 调用 result=(*p)(a,b) 函数名作为参数 &#123; int sum(int a,int b)也是一个子函数 void coun(int(*p)(int,int),int a,int b)也是子函数 用法 count(sum,a,b) 然后进入coun函数内此时*p指向的是sum &#125; &#125;指针数组(适合用来处理字符串)&#123; 不要与行指针相混淆--int (*p)[4] 类型名*数组名【数组长度】 int *p[n] 存放n个指向整型的指针;定义要用=&#123;&amp;a,&amp;b等等&#125; &#125;多重指针（一般不超过2层）&#123; int a=10; int *p1=&amp;a; int **p2=&amp;p1; &#125; 带参数的main函数&#123; 没看懂。 &#125;","categories":[],"tags":[{"name":"c语言 指针","slug":"c语言-指针","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88/"}]},{"title":"Solidity","slug":"Solidity","date":"2022-11-16T05:56:09.000Z","updated":"2022-11-26T08:43:21.283Z","comments":true,"path":"2022/11/16/Solidity/","link":"","permalink":"http://midsummer.github.io.com/2022/11/16/Solidity/","excerpt":"Solidity学习笔记 这篇Blog我会持续update 这是本人第一篇blog，我真的非常开心能够拥有自己的blog，不说废话了，开始学习. [toc]","text":"Solidity学习笔记 这篇Blog我会持续update 这是本人第一篇blog，我真的非常开心能够拥有自己的blog，不说废话了，开始学习. [toc] Solidity基础先温习之前学过了的内容 变量类型 数值类型 布尔型 12//初始化bool public _bool = true;//or false 初始值是false 运算符号 有 与&amp;&amp; 非 ! 或|| 等于 == 不等于!= 均遵循数学逻辑. 整型 123int //整数uint //正整数uint256 //256位正整数 运算包括 +加 -减 *乘 /除 %求余 **幂 比较大小 枚举 这个太冷门不做总结 地址 1address public _address1 //初始值为0x0000000000000 定长字节数组 1byte public _byte //固定长度的字节数组 注意若定义数组为uint 若不定义第一个元素的类型则固定为最小类型 函数类型 pure 不能读取也不能写入储存在链上的状态变量 view 能读取但不能写入状态变量 特点：都不消耗gas internal 只能由合约内部调用，而合约外部不能 external 合约外部可以调用，但合约内部不行 payable 递钱，能给合约支付eth的函数 函数输出 return 用于函数主体，返回指定的变量 returns 加在函数名后面，声明返回的变量类型和变量名 命名式返回和解构式赋值 可以在returns中表明返回类型的名称，这样不需要加return 都可以自动初始化变量并返回对应变量的值 支持返回全部或部分返回值 1234uint256 _number;bool _bool;uint256[3] memory _array;(_number, _bool, _array) = returnNamed(); 1(, _bool2, ) = returnNamed(); 变量数据储存和作用域引用类型和数据位置数组，结构体，映射，在使用时候必须声明出储存位置 storage 状态变量默认都是storage，储存在链上 memory 参数和临时变量一般用这个，储存在内存，不上链 calldata 储存在内存，不上链，特点定义后不能修改 赋值规则 storage赋值给storage时会创建引用，修改其中一个值，会改变另外一个引用的或被引用的值 storage赋值给memory,互不影响 变量的作用域Gas消耗量 状态变量 &gt; 局部变量 全局变量 blockhash(uint blockNumber): (bytes32)给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。 block.coinbase: (address payable) 当前区块矿工的地址 block.gaslimit: (uint) 当前区块的gaslimit block.number: (uint) 当前区块的number block.timestamp: (uint) 当前区块的时间戳，为unix纪元以来的秒 gasleft(): (uint256) 剩余 gas msg.data: (bytes calldata) 完整call data msg.sender: (address payable) 消息发送者 (当前 caller) msg.sig: (bytes4) calldata的前四个字节 (function identifier) msg.value: (uint) 当前交易发送的wei值 引用类型数组12345678uint[8] array1; //初始化 固定数组bytes1[5] array2;address[100] array3;uint[] array4; //可变长度 bytes1[] array5;address[] array6;bytes array7; 动态数组，需要一个一个元素的赋值 对于memory修饰的动态数组，可以用new操作符来创建，但是必须声明长度，并且声明后长度不能改变 数组成员 length: 数组有一个包含元素数量的length成员，memory数组的长度在创建后是固定的。 push(): 动态数组和bytes拥有push()成员，可以在数组最后添加一个0元素。 push(x): 动态数组和bytes拥有push(x)成员，可以在数组最后添加一个x元素。 pop(): 动态数组和bytes拥有pop()成员，可以移除数组最后一个元素。 结构体相当于定义一个新的类型 12345678910111213141516171819202122232425 // 结构体 struct Student&#123; uint256 id; uint256 score; &#125; Student student; // 初始一个student结构体 // 给结构体赋值// 方法1:在函数中创建一个storage的struct引用,利用storage to storage 的引用间接赋值 function initStudent1() external&#123; Student storage _student = student; // assign a copy of student _student.id = 11; _student.score = 100; &#125; // 方法2:直接引用状态变量的struct function initStudent2() external&#123; student.id = 1; student.score = 80; &#125; 映射使用键(key) &#x3D;&gt; 值(value) 声明映射的格式为mapping(_KeyType =&gt; _ValueType)，其中_KeyType和_ValueType分别是Key和Value的变量类型。 1234//初始化mapping(uint =&gt; address) pubilc idToAddress //使用id 可查询地址mapping(address =&gt; address) pubilic swappair //地址对应地址idToAddress[214134] = 0x00000000 //为idtoaddress新增键值对 Rule 映射的_KeyType只能选择solidity默认的类型，比如uint，address等，不能用自定义的结构体。而_ValueType可以使用自定义的类型。 映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量，和library函数的参数（见例子）。不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系 (key - value pair)。 如果映射声明为public，那么solidity会自动给你创建一个getter函数，可以通过Key来查询对应的Value。 给映射新增的键值对的语法为_Var[_Key] = _Value，其中_Var是映射变量名，_Key和_Value对应新增的键值对 原理 映射不储存任何键（Key）的资讯，也没有length的资讯。 映射使用keccak256(key)当成offset存取value。 因为Ethereum会定义所有未使用的空间为0，所以未赋值（Value）的键（Key）初始值都是0。 变量初始值值类型初始值 boolean: false string: &quot;&quot; int: 0 uint: 0 enum: 枚举中的第一个元素 address: 0x0000000000000000000000000000000000000000 (或 address(0)) &#96;&#96;&#96;function 1234567891011121314151617181920212223242526 - `internal`: 空白方程 - `external`: 空白方程#### 引用类型初始值- 映射`mapping`: 所有元素都为其默认值的`mapping`- 结构体`struct`: 所有成员设为其默认值的结构体- 数组`array` - 动态数组: `[]` - 静态数组（定长）: 所有成员设为其默认值的静态数组#### delete`delete a`会让变量`a`的值变为初始值。### 常数&gt; 只有数值变量可以声明`constant`和`immutable`；`string`和`bytes`可以声明为`constant`，但不能为`immutable`。#### constant必须在声明的时候便初始化,之后再也改变不了```solidityuint256 constant CONSTANT_NUM = 10; //初始化 immutable可以在声明时，或者在构造函数,自定义函数中初始化，之后再也不能改变 12345678910uint public immutable A = 999;uint public immutable B;uint public immutable C;constructor()&#123; //构造函数 B = 999;&#125;B = putin();function putin(uint256 d) external pure returns(uint256)&#123; //自定义函数 return(d);&#125; 控制流Solidity的控制流与其他语言类似，主要包含以下几种： if-else 1234567function ifElseTest(uint256 _number) public pure returns(bool)&#123; if(_number == 0)&#123; return(true); &#125;else&#123; return(false); &#125;&#125; for循环 1234567function forLoopTest() public pure returns(uint256)&#123; uint sum = 0; for(uint i = 0; i &lt; 10; i++)&#123; sum += i; &#125; return(sum);&#125; while循环 123456789function whileTest() public pure returns(uint256)&#123; uint sum = 0; uint i = 0; while(i &lt; 10)&#123; sum += i; i++; &#125; return(sum);&#125; do-while循环 123456789function doWhileTest() public pure returns(uint256)&#123; uint sum = 0; uint i = 0; do&#123; sum += i; i++; &#125;while(i &lt; 10); return(sum);&#125; 三元运算符 三元运算符是solidity中唯一一个接受三个操作数的运算符，规则条件? 条件为真的表达式:条件为假的表达式。 此运算符经常用作 if 语句的快捷方式。 12345// 三元运算符 ternary/conditional operatorfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256)&#123; // return the max of x and y return x &gt;= y ? x: y; &#125; 另外还有continue（立即进入下一个循环）和break（跳出当前循环）关键字可以使用。 构造函数和修饰器构造函数一种特殊函数，每个合约仅有一个，并且只在部署合约时运行一次。用来初始化合约的一些参数. 123456address owner; // 定义owner变量// 构造函数constructor() &#123; owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址&#125; 修饰器修饰器（modifier）是solidity特有的语法，类似于面向对象编程中的decorator，声明函数拥有的特性，并减少代码冗余。 12345// 定义modifier onlyowner &#123; require(msg.sender == owner);// 检查调用者是否为owner地址 _;// 如果是的话，继续运行函数主体；否则报错并revert交易&#125; 事件Solidity中的事件（event）是EVM上日志的抽象，它具有两个特点： 响应：应用程序（ether.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。 经济：事件是EVM上比较经济的存储数据的方式，每个大概消耗2,000 gas；相比之下，链上存储一个新变量至少需要20,000 gas. 12//定义event Transfer(address indexed from, address indexed to, uint256 value); 事件的声明由event关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。使用emit可以释放事件. indexed标记的变量可以理解为检索事件的索引“键”，在以太坊上单独作为一个topic进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个事件最多有3个带indexed的变量。每个 indexed 变量的大小为固定的256比特。事件的哈希以及这三个带indexed的变量在EVM日志中通常被存储为topic。其中topic[0]是此事件的keccak256哈希，topic[1]到topic[3]存储了带indexed变量的keccak256哈希。 123456789101112131415// 定义_transfer函数，执行转账逻辑function _transfer( address from, address to, uint256 amount) external &#123; _balances[from] = 10000000; // 给转账地址一些初始代币 _balances[from] -= amount; // from地址减去转账数量 _balances[to] += amount; // to地址加上转账数量 // 释放事件 emit Transfer(from, to, amount);&#125; 继承函数的继承规则 virtual: 父合约中的函数，如果希望子合约重写，需要加上virtual关键字。 override：子合约重写了父合约中的函数，需要加上override关键字。 12345678910111213141516contract A &#123;function XXX() virtual &#123;....&#125;.......&#125;contract B is A&#123;function XXX() virtual override &#123;....&#125;.......&#125;contract C is A, B&#123;function XXX() override(A, B) // 重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约的名字.......&#125; 修饰器的继承Solidity中的修饰器（Modifier）同样可以继承，用法与函数继承类似，在相应的地方加virtual和override关键字即可。 123456789101112131415161718192021contract Base1 &#123; modifier exactDividedBy2And3(uint _a) virtual &#123; require(_a % 2 == 0 &amp;&amp; _a % 3 == 0); _; &#125;&#125;contract Identifier is Base1 &#123; //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数 function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) &#123; return getExactDividedBy2And3WithoutModifier(_dividend); &#125; //计算一个数分别被2除和被3除的值 function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint)&#123; uint div2 = _dividend / 2; uint div3 = _dividend / 3; return (div2, div3); &#125;&#125; 直接引用或者重写 1234modifier exactDividedBy2And3(uint _a) override &#123; _; require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);&#125; 构造函数的继承子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约A里面有一个状态变量a，并由构造函数的参数来确定： 12345678// 构造函数的继承abstract contract A &#123; uint public a; constructor(uint _a) &#123; a = _a; &#125;&#125; 在继承时声明父构造函数的参数，例如：contract B is A(1) 在子合约的构造函数中声明构造函数的参数，例如： 123contract C is A &#123; constructor(uint _c) A(_c * _c) &#123;&#125;&#125; 调用父合约的函数 直接调用：子合约可以直接用父合约名.函数名()的方式来调用父合约函数. 123function F() public&#123; A.XXX();&#125; super关键字,子合约可以利用super.函数名()来调用最近的父合约函数。 123function G() public&#123; super.XXX();&#125; 抽象合约如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体&#123;&#125;中的内容，则必须将该合约标为abstract，不然编译会报错；另外，未实现的函数需要加virtual，以便子合约重写。拿我们之前的插入排序合约为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为abstract，之后让别人补写上。 123abstract contract H&#123;....&#125; 异常errorerror是solidity 0.8版本新加的内容，方便且高效（省gas）地向用户解释操作失败的原因。人们可以在contract之外定义异常。 搭配revert使用 1234567error TransferNotOwner(); // 自定义error function transferOwner1(uint256 tokenId, address newOwner) public &#123; if(_owners[tokenId] != msg.sender)&#123; revert TransferNotOwner(); &#125; _owners[tokenId] = newOwner; &#125;//我们定义了一个transferOwner1()函数，它会检查代币的owner是不是发起人，如果不是，就会抛出TransferNotOwner异常；如果是的话，就会转账。 requirerequire命令是solidity 0.8版本之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高。使用方法：require(检查条件，&quot;异常的描述&quot;)，当检查条件不成立的时候，就会抛出异常。 1234function transferOwner2(uint256 tokenId, address newOwner) public &#123; require(_owners[tokenId] == msg.sender, &quot;Transfer Not Owner&quot;); _owners[tokenId] = newOwner;&#125; assertassert命令一般用于程序员写程序debug，因为它不能解释抛出异常的原因（比require少个字符串）。它的用法很简单，assert(检查条件），当检查条件不成立的时候，就会抛出异常。 1234function transferOwner3(uint256 tokenId, address newOwner) public &#123; assert(_owners[tokenId] == msg.sender); _owners[tokenId] = newOwner;&#125; Gas使用量 error &lt; assert &lt; require Solidity进阶函数重载即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。 修饰器不允许重载 1234567//例子function say() public pure returns(string memory)&#123; return(&quot;Fuck&quot;);&#125;function say(string memory words) public pure returns(string memory)&#123; return(words);&#125; 实参匹配在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。 如果出现多个匹配的重载函数，则会报错。如以下——我们调用f(50)，因为50既可以被转换为uint8，也可以被转换为uint256，因此会报错。 1234567function f(uint8 _in) public pure returns (uint8 out) &#123; out = _in;&#125;function f(uint256 _in) public pure returns (uint256 out) &#123; out = _in;&#125; 库函数 站在巨人的肩膀上(提升solidity代码的复用性和减少gas而存在)——-由大神或者项目方创作 不能存在状态变量 不能够被继承或被继承 不能接受ETH 不可以被销毁 例子 1234library strings &#123;..............//内容省略&#125;//库函数strings//他主要包含两个函数，toString()将uint256转为string，toHexString()将uint256转换为16进制，在转换为string。 使用库函数 using A for B 指令using A for B;可用于附加库函数（从库 A）到任何类型（B）。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。 注意：在调用的时候，这个变量会被当作第一个参数传递给函数： 123456// 利用using for指令using Strings for uint256;function getString1(uint256 _number) public pure returns(string memory)&#123;// 库函数会自动添加为uint256型变量的成员 return _number.toHexString();&#125; 通过库合约名称调用库函数 1234// 直接通过库合约名调用function getString2(uint256 _number) public pure returns(string memory)&#123; return Strings.toHexString(_number);&#125; 几种常用库函数 String：将uint256转换为String Address：判断某个地址是否为合约地址 Create2：更安全的使用Create2 EVM opcode Arrays：跟数组相关的库函数 import solidity支持利用import关键字导入其他源代码中的合约，让开发更加模块化。 相对位置导入 例如：当strom.sol 和 jean.sol在同一目录下时 1improt &#x27;./jean.sol&#x27;; 通过源文件网址导入网上的合约 12// 通过网址引用import &#x27;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol&#x27;; 通过npm目录导入 1import &#x27;@openzeppelin/contracts/access/Ownable.sol&#x27;; 通过全局符号导入特定合约 1import &#123;Yeye&#125; from &#x27;./Yeye.sol&#x27;; 引用(import)在代码中的位置为：在声明版本号之后，在其余代码之前 接受ETH和fallback回调receive()和fallback()，他们主要在两种情况下被使用： 接收ETH 处理合约中不存在的函数调用（代理合约proxy contract） 在solidity 0.6.x版本之前，语法上只有 fallback() 函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。 0.6版本之后，solidity才将 fallback() 函数拆分成 receive() 和 fallback() 两个函数。 receivereceive()只用于处理接收ETH。一个合约最多有一个receive()函数，声明方式与一般函数不一样，不需要function关键字：receive() external payable &#123; ... &#125;。receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable。 1234event received(address sender, uint value);receive() external payable &#123;emit received(msg.sender, msg.value);&#125; fallbackfallback()函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract。fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收ETH:fallback() external payable &#123; ... &#125;。 1234// fallbackfallback() external payable&#123; emit fallbackCalled(msg.sender, msg.value, msg.data);&#125; 差别触发规则123456789101112触发fallback() 还是 receive()? 接收ETH | msg.data是空？ / \\ 是 否 / \\receive()存在? fallback() / \\ 是 否 / \\receive() fallback() receive()和payable fallback()均不存在的时候，向合约发送ETH将会报错。 发送ETH Solidity有三种方法向其他合约发送ETH，他们是：transfer()，send()和call()，其中call()是被鼓励的用法。","categories":[],"tags":[{"name":"solidity smartcontract","slug":"solidity-smartcontract","permalink":"http://midsummer.github.io.com/tags/solidity-smartcontract/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-11-14T11:46:17.891Z","updated":"2022-11-20T08:10:44.649Z","comments":true,"path":"2022/11/14/hello-world/","link":"","permalink":"http://midsummer.github.io.com/2022/11/14/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"solidity","slug":"solidity","permalink":"http://midsummer.github.io.com/tags/solidity/"},{"name":"c语言 文件操作","slug":"c语言-文件操作","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"c语言","slug":"c语言","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"c语言 结构体 链表","slug":"c语言-结构体-链表","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E7%BB%93%E6%9E%84%E4%BD%93-%E9%93%BE%E8%A1%A8/"},{"name":"c语言 error","slug":"c语言-error","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-error/"},{"name":"c语言 竞赛","slug":"c语言-竞赛","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E7%AB%9E%E8%B5%9B/"},{"name":"c语言 指针","slug":"c语言-指针","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88/"},{"name":"solidity smartcontract","slug":"solidity-smartcontract","permalink":"http://midsummer.github.io.com/tags/solidity-smartcontract/"}]}