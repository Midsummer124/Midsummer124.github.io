{"meta":{"title":"Midsummer124的Blog","subtitle":"忘记了过去，迷失在未来","description":"cuit大学，目前freshman一枚","author":"Midsummer124","url":"http://Midsummer.github.io.com","root":"/"},"pages":[{"title":"","date":"2022-11-17T05:32:18.810Z","updated":"2022-11-17T05:26:17.684Z","comments":true,"path":"photos/生活剪影.html","permalink":"http://midsummer.github.io.com/photos/%E7%94%9F%E6%B4%BB%E5%89%AA%E5%BD%B1.html","excerpt":"","text":"故乡的风景 夜爬龙泉山的日出 学校的猫 校园风光"}],"posts":[{"title":"Android","slug":"Android","date":"2022-12-24T14:14:09.000Z","updated":"2022-12-25T08:28:12.764Z","comments":true,"path":"2022/12/24/Android/","link":"","permalink":"http://midsummer.github.io.com/2022/12/24/Android/","excerpt":"简单页面设计","text":"简单页面设计 创建main_activity 首先重写onCreate()方法 创建布局.xml 在AndroidManifest文件中注册 1234567891011121314&lt;activity android:name=&quot;.MainActivity&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;meta-data android:name=&quot;android.app.lib_name&quot; android:value=&quot;&quot; /&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.MainActivity2&quot;/&gt; 以上是为主活动的必要设置 123456789public class TextViewActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_text_view2); //应用刚刚创建的布局 &#125;&#125; 使用id获取定义的元素1234567891011public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); TextView tm = findViewById(R.id.textmain); tm.setText(&quot;你好，李焕英!&quot;); &#125; &#125;); &#125; 使用Toast 在activity.xml中加入button 在activity.java的onCreate中加入监听器 12345678910111213141516public class MainActivity2 extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main2); Button button1 = (Button) findViewById(R.id.mainbutton2); button1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(MainActivity2.this, &quot;you clicked mainbutton2 &quot;, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; maketext()有三个变量，分别是Context,显示的文本内容，显示的时间 创建Menu 于main_activity.java中重写(ctrl+o)**onCreateOptionsMenu()**方法 1234public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return true; &#125; 定义菜单响应事件,重写onOptionsItemSelected 123456789101112public boolean onOptionsItemSelected(@NonNull MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.add_item: Toast.makeText(this, &quot;you clicked Add&quot;, Toast.LENGTH_SHORT).show(); break; case R.id.remove_item: Toast.makeText(this, &quot;you clicked Remove&quot;, Toast.LENGTH_SHORT).show(); break; default: &#125; return true; &#125; 销毁一个activity(known as ‘back’) 通过使用finish()函数与监听器挂钩执行 1234567Button button2 = (Button) findViewById(R.id.mainbutton3); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; finish(); &#125; &#125;); 显式Intent-&gt;启动activity 使用Intent(Context packageContext, Class&lt;?&gt;cls) Activity类startActivity(intent参数) 12345678Button button4 =(Button) findViewById(R.id.mainbutton4); button4.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent1 = new Intent(MainActivity2.this, MainActivity3.class); startActivity(intent1); &#125; &#125;); 隐式Intent 于Androidmanifest.xml添加 123456789&lt;activity android:name=&quot;.MainActivity2&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 指明了当前活动可以响应”com.example.activitytest.ACTION_START” 包含附加信息，更精确指明当前活动能够响应的Intent还可能带有的category 只有和能够同时匹配上Intent中指定的action和category时，这个活动才能够响应 该Intent 添加category 调用intent类的addcategory()方法 ​ 修改之前的button 12345public void onClick(View v) &#123; Intent intent2 = new Intent(&quot;com.example.activitytest.ACTION_START&quot;); intent2.addCategory(&quot;com.example.activitytest.MY_CATEGORY&quot;); startActivity(intent2); &#125; ​ 注意需要在androidmanifest中的中添加该category的声明否则程序会崩溃 12345&lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;category android:name=&quot;com.example.activitytest.MY_CATEGORY&quot;/&gt; &lt;/intent-filter&gt; 更多Intent的用法 打开系统浏览器的网页 指定Intent.ACTION_VIEW 通过uri.parse()将浏览器网址解析为Uri对象 123456789Button button2 = (Button) findViewById(R.id.main1button1); button2.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(&quot;https://midsummer124.github.io/&quot;)); startActivity(intent); &#125; &#125;); data标签 于Androidmanifest添加 12345&lt;intent-filter tools:ignore=&quot;AppLinkUrlError&quot;&gt; &lt;action android:name=&quot;android.intent.action.VIEW&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;data android:scheme=&quot;http&quot;/&gt; &lt;/intent-filter&gt; 只有data标签中指定的内容和Intent中携带的Data完全一致,当前活动才能响应Intent 除了能指定http协议外,还有geo（地理位置）,tel（打电话） 12345public void onClick(View v) &#123; Intent intent2 = new Intent(Intent.ACTION_DIAL); intent2.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent2); &#125; 文本设置 在activity.java下设置 123456789101112public class TextViewActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_text_view2); TextView tv = findViewById(R.id.tv_hello); tv.setText(&quot;I&#x27;m a good man.&quot;); //或使用以在string里设置好的 tv.setText(R.string.hello);//string里有hello的内容 &#125;&#125;//textviewactivity.java 直接在activity.xml设置 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; &lt;TextView android:id=&quot;@+id/tv_hello&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;@string/hello&quot;/&gt; //此处直接于string里引用增加代码复用性&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;","categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://midsummer.github.io.com/tags/android/"}]},{"title":"Java","slug":"Java","date":"2022-12-20T06:29:52.000Z","updated":"2022-12-20T06:29:52.413Z","comments":true,"path":"2022/12/20/Java/","link":"","permalink":"http://midsummer.github.io.com/2022/12/20/Java/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Ethernaut靶场","slug":"Ethernaut靶场","date":"2022-12-05T08:55:26.000Z","updated":"2022-12-05T14:43:53.527Z","comments":true,"path":"2022/12/05/Ethernaut靶场/","link":"","permalink":"http://midsummer.github.io.com/2022/12/05/Ethernaut%E9%9D%B6%E5%9C%BA/","excerpt":"First123456789101112131415161718192021222324252627282930313233343536await contract.info()&#x27;You will find what you need in info1().&#x27;await contract.info1()&#x27;Try info2(), but with &quot;hello&quot; as a parameter.&#x27;await contract.info2(&quot;hello&quot;)&#x27;The property infoNum holds the number of the next info method to call.&#x27;await contract.infoNum()i &#123;negative: 0, words: Array(2), length: 1, red: null&#125;await Array(2)(2) [空 ã2]await contract.info42()&#x27;theMethodName is the name of the next method.&#x27;await contract.theMethodName()&#x27;The method name is method7123949.&#x27;await contract.method7123949()&#x27;If you know the password, submit it to authenticate().&#x27;await contract.authenticate(&quot;7123949&quot;)6b61b19……017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0x1487856…6b61b19……017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0x1487856…&#123;tx: &#x27;0x1487856e49facc25b8e4b9bf756d0dedae08acf7ad3e4e4932da27128741d5a3&#x27;, receipt: &#123;…&#125;, logs: Array(0)&#125;6b61b19……017401cf9cb2bb.js:1 |[●▪▪●]| Submitting level instance... &lt; &lt; &lt;&lt;PLEASE WAIT&gt;&gt; &gt; &gt;6b61b19……017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0x96041a4…6b61b19……017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0x96041a4…6b61b19……017401cf9cb2bb.js:1 ( ͡ °~͡° ) Oops! Looks like you haven&#x27;t cracked this level just yet ( ͡ °~͡° )await contract.password()&#x27;ethernaut0&#x27;await contract.authenticate(&#x27;ethernaut0&#x27;)6b61b19……017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0x62bdff3…6b61b19……017401cf9cb2bb.js:1 (-(-_(-_-)_-)-) Submitting level instance... &lt; &lt; &lt;&lt;PLEASE WAIT&gt;&gt; &gt; &gt;6b61b19……017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0x9b81cca…6b61b19……017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0x62bdff3…&#123;tx: &#x27;0x62bdff30ab90aea56011aecc158873ced93bf7e529bb6eb569f3b791fab272a7&#x27;, receipt: &#123;…&#125;, logs: Array(0)&#125;6b61b19……017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0x9b81cca…6b61b19……017401cf9cb2bb.js:1 ╚(▲_▲)╝ Well done, You have completed this level!!!6b61b19……017401cf9cb2bb.js:1 ╚(▲_▲)╝ Well done, You have completed this level!!!","text":"First123456789101112131415161718192021222324252627282930313233343536await contract.info()&#x27;You will find what you need in info1().&#x27;await contract.info1()&#x27;Try info2(), but with &quot;hello&quot; as a parameter.&#x27;await contract.info2(&quot;hello&quot;)&#x27;The property infoNum holds the number of the next info method to call.&#x27;await contract.infoNum()i &#123;negative: 0, words: Array(2), length: 1, red: null&#125;await Array(2)(2) [空 ã2]await contract.info42()&#x27;theMethodName is the name of the next method.&#x27;await contract.theMethodName()&#x27;The method name is method7123949.&#x27;await contract.method7123949()&#x27;If you know the password, submit it to authenticate().&#x27;await contract.authenticate(&quot;7123949&quot;)6b61b19……017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0x1487856…6b61b19……017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0x1487856…&#123;tx: &#x27;0x1487856e49facc25b8e4b9bf756d0dedae08acf7ad3e4e4932da27128741d5a3&#x27;, receipt: &#123;…&#125;, logs: Array(0)&#125;6b61b19……017401cf9cb2bb.js:1 |[●▪▪●]| Submitting level instance... &lt; &lt; &lt;&lt;PLEASE WAIT&gt;&gt; &gt; &gt;6b61b19……017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0x96041a4…6b61b19……017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0x96041a4…6b61b19……017401cf9cb2bb.js:1 ( ͡ °~͡° ) Oops! Looks like you haven&#x27;t cracked this level just yet ( ͡ °~͡° )await contract.password()&#x27;ethernaut0&#x27;await contract.authenticate(&#x27;ethernaut0&#x27;)6b61b19……017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0x62bdff3…6b61b19……017401cf9cb2bb.js:1 (-(-_(-_-)_-)-) Submitting level instance... &lt; &lt; &lt;&lt;PLEASE WAIT&gt;&gt; &gt; &gt;6b61b19……017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0x9b81cca…6b61b19……017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0x62bdff3…&#123;tx: &#x27;0x62bdff30ab90aea56011aecc158873ced93bf7e529bb6eb569f3b791fab272a7&#x27;, receipt: &#123;…&#125;, logs: Array(0)&#125;6b61b19……017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0x9b81cca…6b61b19……017401cf9cb2bb.js:1 ╚(▲_▲)╝ Well done, You have completed this level!!!6b61b19……017401cf9cb2bb.js:1 ╚(▲_▲)╝ Well done, You have completed this level!!! SecondLook carefully at the contract’s code below. You will beat this level if you claim ownership of the contract you reduce its balance to 0 Things that might help How to send ether when interacting with an ABI How to send ether outside of the ABI Converting to and from wei&#x2F;ether units (see help() command) Fallback methods 123456789101112131415161718192021222324252627282930313233343536373839404142// SPDX-License-Identifier: MITpragma solidity ^0.8.0;contract Fallback &#123; mapping(address =&gt; uint) public contributions; address public owner; constructor() &#123; owner = msg.sender; contributions[msg.sender] = 1000 * (1 ether); &#125; modifier onlyOwner &#123; require( msg.sender == owner, &quot;caller is not the owner&quot; ); _; &#125; function contribute() public payable &#123; require(msg.value &lt; 0.001 ether); contributions[msg.sender] += msg.value; if(contributions[msg.sender] &gt; contributions[owner]) &#123; owner = msg.sender; &#125; &#125; function getContribution() public view returns (uint) &#123; return contributions[msg.sender]; &#125; function withdraw() public onlyOwner &#123; payable(owner).transfer(address(this).balance); &#125; receive() external payable &#123; require(msg.value &gt; 0 &amp;&amp; contributions[msg.sender] &gt; 0); owner = msg.sender; &#125;&#125; 123456789101112131415161718192021222324252627toWei(&quot;0.0001&quot;)&#x27;100000000000000&#x27;contract.contribute.sendTransaction(&#123;from:player, value:&#x27;100000000000000&#x27;&#125;)Promise &#123;&lt;pending&gt;, _events: i, emit: ƒ, on: ƒ, …&#125;6b61b19c2493b650292ddc5f54017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0xbf921f3431bb4495c98c822ab44c9d040de15a2bb76ba7600218bc88b4e94f3c6b61b19c2493b650292ddc5f54017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0xbf921f3431bb4495c98c822ab44c9d040de15a2bb76ba7600218bc88b4e94f3cawait contract.owner()&#x27;0x80934BE6B8B872B364b470Ca30EaAd8AEAC4f63F&#x27;contract.sendTransaction(&#123;from:player, value:&#x27;100000000000000&#x27;&#125;)Promise &#123;&lt;pending&gt;, _events: i, emit: ƒ, on: ƒ, …&#125;6b61b19c2493b650292ddc5f54017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0x7f742a4171f80bcefeec38900b58a8c7385c016202f458f9e58e736536f9d3ee6b61b19c2493b650292ddc5f54017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0x7f742a4171f80bcefeec38900b58a8c7385c016202f458f9e58e736536f9d3eeawait contract.owner()&#x27;0x5957beeD07344DFFAB3db3bAB0d5fB4dc6eF29Bc&#x27;Number(contract.getContribution())NaNawait contract.getContribution()i &#123;negative: 0, words: Array(3), length: 2, red: null&#125;length: 2negative: 0red: nullwords: Array(3)0: 80117761: 1490116length: 3[[Prototype]]: Array(0)[[Prototype]]: Objectcontract.withdraw()Promise &#123;&lt;pending&gt;, _events: i, emit: ƒ, on: ƒ, …&#125;6b61b19c2493b650292ddc5f54017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0xcb5cf8a571768d5b1723efd2a5cf3ff118a62433a521fa7ae1c4761a3baf20e66b61b19c2493b650292ddc5f54017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0xcb5cf8a571768d5b1723efd2a5cf3ff118a62433a521fa7ae1c4761a3baf20e66b61b19c2493b650292ddc5f54017401cf9cb2bb.js:1 ☜Ҩ.¬_¬.Ҩ☞ Submitting level instance... &lt; &lt; &lt;&lt;PLEASE WAIT&gt;&gt; &gt; &gt;6b61b19c2493b650292ddc5f54017401cf9cb2bb.js:1 ⛏️ Sent transaction ⛏ https://goerli.etherscan.io/tx/0xac3d8c51e37b85a0e6598c08a7fba57eff3828fde84d51ec05e0fff28141472f6b61b19c2493b650292ddc5f54017401cf9cb2bb.js:1 ⛏️ Mined transaction ⛏ https://goerli.etherscan.io/tx/0xac3d8c51e37b85a0e6598c08a7fba57eff3828fde84d51ec05e0fff28141472f6b61b19c2493b650292ddc5f54017401cf9cb2bb.js:1 ヽ(￣(ｴ)￣)ﾉ Well done, You have completed this level!!!6b61b19c2493b650292ddc5f54017401cf9cb2bb.js:1 ヽ(￣(ｴ)￣)ﾉ Well done, You have completed this level!!! Third","categories":[],"tags":[{"name":"solidity","slug":"solidity","permalink":"http://midsummer.github.io.com/tags/solidity/"}]},{"title":"svip","slug":"svip","date":"2022-12-02T06:36:59.000Z","updated":"2022-12-05T08:54:39.899Z","comments":true,"path":"2022/12/02/svip/","link":"","permalink":"http://midsummer.github.io.com/2022/12/02/svip/","excerpt":"","text":"合约已部署 从 svip 合约可知，成为 svip 至少需要999 points，而我们一开始 numofree 只能为我们提供100 points. 合约地址: 0xb14a483BA2F59d5C34CB0e3C43f94ff2f486dEc5","categories":[],"tags":[{"name":"solidity","slug":"solidity","permalink":"http://midsummer.github.io.com/tags/solidity/"}]},{"title":"文件操作","slug":"文件操作","date":"2022-12-01T03:28:22.000Z","updated":"2022-12-05T08:58:36.415Z","comments":true,"path":"2022/12/01/文件操作/","link":"","permalink":"http://midsummer.github.io.com/2022/12/01/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","excerpt":"文件操作略学了一点","text":"文件操作略学了一点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980使用FILE *fp;来创建文件指针fopen(&quot;文件位置&quot;,&quot;打开方式&quot;);文件位置1. 绝对位置 全盘路径 2. 相对位置 同级目录 下级目录 上级目录打开方式1.&quot;r&quot; 只读 若不存在-报错 2.&quot;w&quot; 只写 若不存在-新建 3.&quot;a&quot; 追加 若不存在-新建 文件结束标记符 EOFchar ch;fp=fopen(&quot;cuit.txt&quot;,&quot;r&quot;);ch=fgetc(fp);fputc(ch,fp);fclose(fp);#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;/*function: 创建cuit2文件，读取cuit文件，将cuit复制到cuit2. */void main()&#123; FILE *fp1,*fp2; char ch; fp1=fopen(&quot;cuit2.txt&quot;,&quot;w&quot;); fp2=fopen(&quot;cuit.txt&quot;,&quot;r&quot;); ch=getc(fp2); while(ch!=EOF) &#123; fputc(ch,fp1); ch=getc(fp2); &#125; fclose(fp1);fclose(fp2); fp1=fopen(&quot;cuit2.txt&quot;,&quot;r&quot;); if(fp1==NULL) &#123; printf(&quot;failed&quot;); exit(0); &#125; ch=fgetc(fp1); while(ch!=EOF) &#123; putchar(ch); ch=fgetc(fp1); &#125; fclose(fp1);&#125;类似于scanf,和printf;功能几乎一样; int a;fscanf(文件指针,&quot;内容例如%d&quot;,&amp;a);fprintf(文件指针,&quot;内容%2d&quot;,a);fgets(字符数组地址,多少,文件指针);fseek(文件指针,偏移量,起始位置)若成功返回0起始位置SEEK_SET： 文件开头 --&gt;&gt; 1SEEK_CUR： 当前位置 --&gt;&gt; 2SEEK_END： 文件结尾 --&gt;&gt; 3","categories":[],"tags":[{"name":"c语言 文件操作","slug":"c语言-文件操作","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"}]},{"title":"传智杯练习","slug":"传智杯练习","date":"2022-11-26T06:58:45.000Z","updated":"2022-11-27T03:57:01.275Z","comments":true,"path":"2022/11/26/传智杯练习/","link":"","permalink":"http://midsummer.github.io.com/2022/11/26/%E4%BC%A0%E6%99%BA%E6%9D%AF%E7%BB%83%E4%B9%A0/","excerpt":"[传智杯 #5 练习赛] 时钟题目描述你有一个电子钟，可以显示 0:00 到 23:59 之间的所有时间，以数字的形式显示。其中小时是 0 到 23（0 时会显示一个 0，而 1 到 9 时不会显示前导 0），分钟是 00 到 59（0 到 9 分都会显示前导 0）。任何时刻，电子钟都会显示三个或者四个 $0$ 到 $9$ 的数字。如果在某时刻，这些数字依次组成了一个等差数列，则这个时刻被称为“好时刻”。 你感觉很无聊，从 0:00 时刻开始盯着这个电子钟。一共盯了 $x$ 分钟。请问整个过程中，”好时刻”来临了多少次（算上开头和结尾）？","text":"[传智杯 #5 练习赛] 时钟题目描述你有一个电子钟，可以显示 0:00 到 23:59 之间的所有时间，以数字的形式显示。其中小时是 0 到 23（0 时会显示一个 0，而 1 到 9 时不会显示前导 0），分钟是 00 到 59（0 到 9 分都会显示前导 0）。任何时刻，电子钟都会显示三个或者四个 $0$ 到 $9$ 的数字。如果在某时刻，这些数字依次组成了一个等差数列，则这个时刻被称为“好时刻”。 你感觉很无聊，从 0:00 时刻开始盯着这个电子钟。一共盯了 $x$ 分钟。请问整个过程中，”好时刻”来临了多少次（算上开头和结尾）？ 输入格式一个不超过 $10^9$ 的非负整数。 输出格式请输出”好时刻”来临了多少次？ 样例 #1样例输入 #11120 样例输出 #1110 样例 #2样例输入 #212880 样例输出 #2179 样例 #3样例输入 #31987654321 样例输出 #3126748975 提示【样例解释】 你观察了 2 个小时，其中这些“好时刻”来临了： 123456789100:000:120:240:360:481:111:231:351:471:59 一共是 10 个。 我的100分解答: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int judge(int a,int b)&#123; int t1,t2,t3,t4; if(a&lt;=9) &#123; t1=0; t2=a; t4=b%10; t3=(b-t4)/10; if(t3-t2==t4-t3) &#123; return 1; &#125; else &#123; return 0; &#125; &#125; else &#123; t2=a%10; t1=(a-t2)/10; t4=b%10; t3=(b-t4)/10; if(t2-t1==t3-t2&amp;&amp;t3-t2==t4-t3&amp;&amp;t2-t1==t4-t3) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;&#125;int main()&#123; int a,b,i,j,x,goodmoment=0,k=0; scanf(&quot;%d&quot;,&amp;x);j=x; if(x&gt;1440) &#123; while(j&gt;1440) &#123; j-=1440; k++; &#125; if(j==1440) &#123; goodmoment+=1; &#125; &#125; for(a=0,b=0;a*60+b&lt;=j;b++) &#123; if(judge(a,b)) &#123; goodmoment++; &#125; if(a==23&amp;&amp;b==59) &#123; break; &#125; if(b==59) &#123; a++; b=0; continue; &#125; &#125; if(k&gt;=1) &#123; printf(&quot;%d&quot;,goodmoment+39*k); &#125; else &#123; printf(&quot;%d&quot;,goodmoment); &#125;&#125; [传智杯 #5 练习赛] 平等的交易题目描述你有 $n$ 件道具可以买，其中第 $i$ 件的价格为 $a_i$。 你有 $w$ 元钱。你仅能用钱购买其中的一件商道具。当然，你可以拿你手中的道具换取其他的道具，只是这些商道具的价值之和，不能超过你打算交换出去的道具。你可以交换无数多次道具。道具的价值可能是 $0$，但是你不能使用空集换取价值为 0 的商品。 请问，在这个条件下，最多可以换取多少件道具？ 输入格式第一行一个正整数 $n$，表示道具个数。 接下来一行 $n$ 个正整数，表示 ${a_n}$。 接下来一行 $1$ 个正整数，表示 $w$。 输出格式一个正整数，表示答案。 样例 #1样例输入 #11233 1 1 25 样例输出 #112 提示【样例解释】 买价值为 $2$ 的道具，并交换为两个价值为 $1$ 的道具。 【数据范围及约束】 测试数据满足，$1 \\leq n\\leq10^6$，$0 \\leq a_i\\leq 10^9$，$1 \\leq w\\leq2\\times10^{9}$。 我的70分解答: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int func(int mip[],int n,int m)&#123; int i; for(i=n-1;i&gt;=0;i--) &#123; if(m&gt;=mip[i]) &#123; return mip[i]; &#125; &#125;&#125;int main()&#123; int n,i,m,cou=0,t,j; // m for money scanf(&quot;%d&quot;,&amp;n); int ip[n],mip[n]; //item price for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d&quot;,&amp;ip[i]); mip[i]=ip[i]; &#125; scanf(&quot;%d&quot;,&amp;m); for(i=0;i&lt;n;i++) for(j=0;j&lt;n-i-1;j++) &#123; if(mip[j]&gt;mip[j+1]) &#123; t=mip[j];mip[j]=mip[j+1];mip[j+1]=t; &#125; &#125; int max=func(mip,n,m); for(i=0;i&lt;n;i++) &#123; if(mip[i]&lt;=max) &#123; cou++; max-=mip[i]; &#125; &#125; printf(&quot;%d&quot;,cou); return 0;&#125; [传智杯 #5 练习赛] 复读题目描述给定若干个字符串，不定数量，每行一个。有些字符串可能出现了多次。如果读入一个字符串后，发现这个字符串以前被读入过，则这个字符串被称为前面相同的字符串的复读，这个字符串被称为复读字符串。相应的，每个首次出现的字符串就是非复读字符串。 举个例子， 12345abcdefabcabcabc 第 $1,3,4,5$ 行是字符串 abc，那么 $3,4,5$ 行的字符串会被称为“复读”。 请你把所有的非复读字符串，按照行号从小到大的顺序，依次拼接为一个长串并输出。 输入格式多个字符串，每行一个，含义见题目描述。 注意：如果这个字符串是 0，说明所有字符串都读完了。这个 0 不认为是一个“非复读字符串”。 输出格式共一行，表示所有非复读字符串，按照行号从小到大依次连接的结果。 样例 #1样例输入 #112345ccbacc0 样例输出 #11ccba 提示【数据范围】 字符串的个数不超过 $500$ 个，字符串总长度不超过 $50000$，每个字符串中只包含小写字母、数字、 . 、! 和 &amp;，不包含空格等特殊符号。 [传智杯 #5 练习赛] 清洁工题目描述有一个 $n\\times n$ 的地块，一个连续 $i$ 分钟没人经过的地面在第 $i$ 分钟会落上 $i$ 个单位的灰，有人经过时不会落灰但灰也不会清零，在人走后第一分钟又会落上一个单位的灰，以此类推。你在这个 $n\\times n$ 的范围内移动，你的移动轨迹可以描述为一个由 $\\text{N,S,W,E}$ 组成的字符串，每个字母分别表示上、下、左、右。这个人一开始在点 $(x,y)$，每一分钟移动一步。 求最后每一个位置上落下的灰的量。 本题中的上和右分别表示 $y$ 轴正方向和 $x$ 轴正方向。保证你没有超过移动的范围。 输入格式第一行四个正整数 $n,m,x,y$，含义如题面所示，其中 $x,y$ 表示横纵坐标，不是数组下标。第二行一个长度为 $m$ 的字符串，表示你的移动序列。 输出格式共$n$ 行，每行 $n$ 个数，第 $i$ 行的第 $j$ 个数表示坐标 $(j,n-i+1)$ 上的灰的数量 样例 #1样例输入 #1125 4 1 1NENW 样例输出 #11234510 10 10 10 10 10 10 10 10 10 10 6 10 10 10 4 4 10 10 10 6 10 10 10 10 样例 #2样例输入 #2127 14 1 1NENENENENESSSS 样例输出 #21234567105 105 105 105 105 105 105 105 105 105 105 55 61 105 105 105 105 49 51 69 105 105 105 51 49 105 79 105 105 61 55 105 105 91 105 79 69 105 105 105 105 105 91 105 105 105 105 105 105 样例 #3样例输入 #31210 70 2 2NWSNSNNNSNNSSNNSENNNNEESNWSESESSWENNSEWESWWWESEEESENNSENWNESNWSNNNEESS 样例输出 #3123456789102485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 1407 1205 1267 2485 2485 2485 2485 2485 2485 2485 1435 1281 1167 2485 2485 2485 2217 2281 2347 2485 1465 2485 1255 1041 2485 2485 2155 2485 2415 1557 1497 2485 2485 969 1177 2485 1733 1807 2485 1471 1531 1315 907 935 1267 2485 1473 1647 2485 1631 2485 2485 1357 1381 1407 1435 1499 1645 2485 2021 2347 2485 2485 2485 2485 1465 1497 2485 2485 2087 2415 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 2485 样例 #4样例输入 #4125 4 2 1NENW 样例输出 #41234510 10 10 10 10 10 10 10 10 10 10 10 6 10 10 10 4 4 10 10 10 6 10 10 10 提示本题 y 轴朝上，x 轴朝右，样例输出中的左下角表示 $(1,1)$，第一分钟你在初始点处，第二分钟移动到相应的位置，第 $m+1$ 分钟移动到最后一个点，但是总共只有 $m$ 分钟，因此最后一个点不受移动的影响 样例 1 解释： 你的移动路径为 $(1,1)\\rightarrow(1,2)\\rightarrow(2,2)\\rightarrow(2,3)\\rightarrow(1,3)$，共 $4$ 分钟。 对于第 $1$ 分钟，$(1,1)$ 灰层数不变，其余点被落下了 $1$ 层灰。 对于第 $2$ 分钟，$(1,2)$ 灰层数不变，$(1,1)$ 被落下了 $1$ 层灰，其余点落下 $2$ 层灰。 对于第 $3$ 分钟，$(2,2)$ 灰层数不变，$(1,1)$ 落下 $2$ 层灰，$(1,2)$ 落下 $1$ 层灰，其余点落下 $3$ 层灰。 对于第 $4$ 分钟，$(2,3)$ 灰层数不变，$(1,1)$ 落下 $3$ 层灰，$(1,2)$ 落下 $2$ 层灰，$(2,2)$ 落下 $1$ 层灰，其余点落下 $4$ 层灰。 注意最后你移动到了 $(1,3)$，但是时间只有 $4$ 分钟，所以实际上不会对 $(1,3)$ 造成影响。初始点不一定在 $(1,1)$。 $1\\le n\\leq 50,1\\leq m\\le 1000$。 半成品: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;#define N 50int k=0,l=0;void ini(int re[][N],int n)&#123; int i,j; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; re[i][j]=0; &#125; &#125;&#125;void move(int *p1, int *p2, int re[][N], char ch, int n)&#123; int i,j,t=*(re[*p1]+*p2); if(k==0) &#123; ini(re,n); k++; &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; *(re[i]+j)+=1; &#125; &#125;// printf(&quot;re:\\n&quot;);// for(i=0;i&lt;n;i++)// &#123;// for(j=0;j&lt;n;j++)// &#123;// printf(&quot;%d &quot;,re[i][j]);// &#125;// putchar(&#x27;\\n&#x27;);// &#125; *(re[*p1]+*p2)=t;// switch(ch)// &#123;// case &#x27;N&#x27;:*p2+=1;break; // case &#x27;S&#x27;:*p2-=1;break; // case &#x27;W&#x27;:*p1-=1;break;// case &#x27;E&#x27;:*p1+=1;break; // default:break;// &#125;// printf(&quot;%d,%d\\n&quot;,*p1,*p2);&#125;void dust(int re[][N], int n, int sq[][N]) //积 灰 &#123; if(l==0) &#123; ini(sq,n); l++; &#125; int i,j; for(i=0;i&lt;n;i++) for(j=0;j&lt;n;j++) *(sq[i]+j)+=*(re[i]+j);// printf(&quot;sq:\\n&quot;);// for(i=0;i&lt;n;i++)// &#123;// for(j=0;j&lt;n;j++)// &#123;// printf(&quot;%d &quot;,sq[i][j]);// &#125;// putchar(&#x27;\\n&#x27;);// &#125;&#125;int main()&#123; int n,m,x,y,i,j; scanf(&quot;%d%d%d%d&quot;,&amp;n,&amp;m,&amp;x,&amp;y); x-=1;y-=1; int *p1,*p2;p1=&amp;x;p2=&amp;y; int sq[n][n],re[n][n]; char ch[1000]; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; re[i][j]=0;sq[i][j]=0; &#125; &#125; getchar(); gets(ch); for(i=0;i&lt;m;i++) &#123; move(p1,p2,re,ch[i],n); dust(re,n,sq); switch(ch[i]) &#123; case &#x27;N&#x27;:*p2+=1;break; case &#x27;S&#x27;:*p2-=1;break; case &#x27;W&#x27;:*p1-=1;break; case &#x27;E&#x27;:*p1+=1;break; default:break; &#125; re[*p1][*p2]=0; &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; printf(&quot;%d &quot;,sq[i][j]); &#125; putchar(&#x27;\\n&#x27;); &#125; for(i=0;i&lt;n;i++) &#123; for(j=0;j&lt;n;j++) &#123; printf(&quot;%d &quot;,re[i][j]); &#125; putchar(&#x27;\\n&#x27;); &#125; return 0;&#125; [传智杯 #5 练习赛] 树的变迁题目描述给定一棵具有 $n$ 个节点的树，每个节点有一个初始权值 $a_i$。 一共需要进行 $m$ 次操作，每次操作包括： 1 e 编号为 $e$ 的边突然消失，使得它所在的那棵树变成了两棵树。 2 u val 编号为 $u$ 的节点的权值变成了 $val$。 3 u 进行了一次查询，查询 $u$ 所在的那棵树的权值之和。 现在你需要来模拟上述事件，以了解树的变迁。 输入格式第一行为 $n, m$，如上所述。 第二行有 $n$ 个数，为 $n$ 个结点的初始权值，在 $10^3$ 以内。 下面 $n-1$ 行，每行一组 $u, v$，表示一条边。（保证初始为一棵树） 下面 $m$ 行有 $m$ 个操作： 先读入一个 $\\text{opt}$，表示操作类型。 $\\text{opt}&#x3D;1$ 时，读入 $e$，表示删掉读入的第 $e$ 条边。（保证第 $e$ 条边存在） $\\text{opt}&#x3D;2$ 时，读入 $u,val$，表示把结点 $u$ 的权值改成 $val$（$val \\le 1000$）。 $\\text{opt}&#x3D;3$ 时，读入 $u$，表示查询 $u$ 所在的那棵树的结点权值和。 输出格式对于每个查询操作，输出一行一个数表示答案。 样例 #1样例输入 #11234562 31 11 22 2 41 13 2 样例输出 #114 提示所有测试数据数据满足 $1 \\leq n,m \\leq {10}^5$，$1 \\leq a_i,val \\leq 1000$。 [传智杯 #5 练习赛] 白色旅人题目描述有一个物品队列 $\\frak B$，初始时为空。现在共有三种操作。每个操作会给定三个整数 $\\mathrm{op},x,y$，其中 $\\mathrm{op}$ 表示操作种类，$x,y$ 是操作的参数。操作分为如下三种： $1$：向 $\\frak B$ 尾部添加一个物品，它的体积为 $x$，价值为 $y$。 $2$：把 $\\frak B$ 尾部最后物品移除。保证此时最少有一个物品。 $3$：有一个体积为 $x$ 的背包。用 $\\frak B$ 内的物品填充它，每个物品最多用一次，询问最多能获得多大的价值。提示：当 $\\frak B$ 为空时，相当于没有物品可用，答案就是 $0$。 对于操作 $2$ 和 $3$，请忽略多余的参数。 本题强制在线。强制在线的方式请见输入格式。 输入格式 第一行有两个正整数 $n,m_{\\max}$，表示操作个数以及操作 $3$ 提到的背包的体积的最大值。 接下来 $n$ 行，每行给定三个整数 $\\mathrm{op},x’,y’$。将 $x’,y’$ 分别异或上 $\\mathrm{lastans}$ 得到该次询问真正的 $x,y$。其中，$\\mathrm{lastans}$ 是上一次操作 $3$ 询问的结果。在第一次操作 $3$ 前，$\\mathrm{lastans}&#x3D;0$。 输出格式 输出有若干行，表示每次 $3$ 操作的结果。 样例 #1样例输入 #1123456789101110 101 3 41 5 53 4 13 12 51 14 33 1 82 11 113 2 112 8 83 12 8 样例输出 #112345491094 提示样例解释解码后的输入数据为： 123456789101110 101 3 41 5 53 4 13 8 11 7 103 8 12 1 13 8 12 1 13 5 1 对于十次操作，物品序列的情况如下； 加入体积为 $3$，价值为 $4$ 的物品。物品序列为 ${(3,4)}$。 加入体积为 $5$，价值为 $5$ 的物品。物品序列为 ${(3,4),(5,5)}$。 查询体积为 $4$ 的背包能装下的物品价值最大值。此时只能装第一个物品，于是答案为 $4$。 查询体积为 $8$ 的背包能装下的物品价值最大值。此时可把两个物品都装下，答案为 $9$。 加入体积为 $7$，价值为 $10$ 的物品。物品序列为 ${(3,4),(5,5),(7,10)}$。 查询体积为 $8$ 的背包能装下的物品价值最大值。此时直接装第三个物品获得的价值大于装下另外两个，于是答案为 $10$。 删除最后一个物品。此时物品序列为 ${(3,4),(5,5)}$。 查询体积为 $8$ 的背包能装下的物品价值最大值。此时可把两个物品都装下，答案为 $9$。 删除最后一个物品。此时物品序列为 ${(3,4)}$。 查询体积为 $5$ 的背包能装下的物品价值最大值。此时只有一个物品可装，答案为 $4$。 数据范围及约定对于全部数据，$1\\le n\\le 3\\times 10^4$，$1\\le m_{\\max}\\le 2\\times 10^4$，$1\\le x, y\\le 2\\times 10^4$。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;//半成品typedef struct item&#123; int p; int v;&#125;it;it bag[2000];int time=0,lastans=0; //lastans为上次询问的结果 time 为背包位置指针 int *t=&amp;time,*la=&amp;lastans;it *pv; //我有的东西 void func(int move,int x,int y)&#123; if(move==1) &#123; *(pv+*t).p=x; *(pv+*t).v=y; &#125; else if(move==2) &#123; *(pv+*t).p=-1; //清空背包位置换为-1 *(pv+*t).v=-1; *t=*t-1; &#125; else if(move==3) &#123; fill_bag(x); &#125;&#125;void fill_bag(int x)&#123; s_max()&#125;int m_max;void main()&#123; int n; scanf(&quot;%d%d&quot;,&amp;n,&amp;m_max); int x,y,i,j,move; pv=(it*)malloc(sizeof(it)*n); for(i=0;i&lt;n;i++) &#123; scanf(&quot;%d %d %d&quot;,move,x,y); func(move,x^(*la),y^(*la)); &#125;&#125;","categories":[],"tags":[{"name":"c语言","slug":"c语言","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"结构体和链表","slug":"结构体和链表","date":"2022-11-24T13:29:05.000Z","updated":"2022-11-25T04:19:38.975Z","comments":true,"path":"2022/11/24/结构体和链表/","link":"","permalink":"http://midsummer.github.io.com/2022/11/24/%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E9%93%BE%E8%A1%A8/","excerpt":"1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;struct student&#123; char name; int age; struct student *next;&#125;;void main()&#123; typedef struct student stu; stu *head,a,b,c,d,*p; head=&amp;a; a.next=&amp;b; b.next=&amp;c; c.next=&amp;d; d.next=NULL; p=head; a.age=20; a.name=&#x27;c&#x27;; b.age=18; b.name=&#x27;g&#x27;; c.age=16; c.name=&#x27;m&#x27;; d.age=70; d.name=&#x27;f&#x27;; while(p!=NULL) &#123; printf(&quot;%c\\n&quot;,p-&gt;name); printf(&quot;%d\\n&quot;,p-&gt;age); p=p-&gt;next; &#125;&#125;","text":"1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;struct student&#123; char name; int age; struct student *next;&#125;;void main()&#123; typedef struct student stu; stu *head,a,b,c,d,*p; head=&amp;a; a.next=&amp;b; b.next=&amp;c; c.next=&amp;d; d.next=NULL; p=head; a.age=20; a.name=&#x27;c&#x27;; b.age=18; b.name=&#x27;g&#x27;; c.age=16; c.name=&#x27;m&#x27;; d.age=70; d.name=&#x27;f&#x27;; while(p!=NULL) &#123; printf(&quot;%c\\n&quot;,p-&gt;name); printf(&quot;%d\\n&quot;,p-&gt;age); p=p-&gt;next; &#125;&#125; Notes 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138结构体的一般定义 struct STU //定义类型 &#123; char num[11]; 并非真的定义变量 char name[20]; char sex[3]; float totalscore; float avgscore;&#125;;初始化struct STU student1,studen2; 系统会自动给这2个人加分配内存紧凑版struct STU &#123; char num[11]; 并非真的定义变量 char name[20]; char sex[3]; float totalscore; float avgscore;&#125;student1,student2;录入数据 struct STU sudent1=&#123;&quot;2018231048&quot;,&quot;李四&quot;,等等&#125;;student1.num=190631scanf(&quot;%s&quot;,student1.num) 不需要加&amp;，已经是地址 若成员学籍号定义为char num[11]则用 strcpy(student1.num,&quot;2023123123&quot;)或gets(student1.num) struct STU *p;指针访问成员p-&gt;name;p-&gt;age;p-&gt;sex; 为指针分配空间 p=(struct STU *)malloc(sizeof(struct STU)*1);scanf(&quot;%s&quot;,p-&gt;name); 结构体中是数组 不用加&amp; scanf(&quot;%f&quot;,&amp;p-&gt;totalscore); 单个数值 要加&amp; int n;scanf(&quot;%d&quot;,&amp;n);struct STU *s1; 指针一条龙 s1=(struct STU)malloc(sizeof(struct STU)*n);for(i=0;i&lt;*n;i++)&#123;scanf(&quot;%d&quot;,&amp;(s1+i)-&gt;name);&#125;嵌套结构体 struct date&#123; int year; int month; int day;&#125;;struct STU &#123; struct date birthday; char num[11]; char name[20]; char sex[3]; float totalscore; float avgscore;&#125;student1,student2;student1.date.year=1998自定义名字 typedef struct student&#123; ..... &#125;stu;可直接使用stu 代表struct student; 结构体 传参 typedef struct student&#123; char name[10]; int weight;&#125;stu;void printstu(stu *studen_1)&#123; printf(&quot;name:%s weight:%d&quot;,studen_1.name,*student_1.weight);&#125;int sum_stu(stu studen_1)&#123; &#125;结构体的 swap stu p1,p2,t;t=p1;p1=p2;p2=t; 共用体union position&#123; int i; int j; char s[20];&#125;p1;成员是共享一个内存空间 =&gt; 同一时刻，一个变量起作用 int p1.i=10;int p1.j=20; p1.i被覆盖 strcpy(p1.s,&quot;fuck&quot;); p1.j被覆盖 最后只有p1.s存在 typedef struct person&#123; int grade; union &#123; char class[20]; char name; &#125;&#125;per;per per1;per1.grade=1;per1.name=george;","categories":[],"tags":[{"name":"c语言 结构体 链表","slug":"c语言-结构体-链表","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E7%BB%93%E6%9E%84%E4%BD%93-%E9%93%BE%E8%A1%A8/"}]},{"title":"c语言错误收集","slug":"c语言错误收集","date":"2022-11-21T07:44:34.000Z","updated":"2022-12-04T12:55:45.615Z","comments":true,"path":"2022/11/21/c语言错误收集/","link":"","permalink":"http://midsummer.github.io.com/2022/11/21/c%E8%AF%AD%E8%A8%80%E9%94%99%E8%AF%AF%E6%94%B6%E9%9B%86/","excerpt":"scanf 和 gets 连用的异常123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int m; scanf(&quot;%d&quot;,&amp;m); char ch[999]; gets(ch); puts(ch); printf(&quot;%d&quot;,m); return 0;&#125; 以上代码，gets运行异常，而去掉scanf，gets正常运行","text":"scanf 和 gets 连用的异常123456789101112131415#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;int main()&#123; int m; scanf(&quot;%d&quot;,&amp;m); char ch[999]; gets(ch); puts(ch); printf(&quot;%d&quot;,m); return 0;&#125; 以上代码，gets运行异常，而去掉scanf，gets正常运行 分析: 实际上我们在输入的时候并非只输入了“值”，除了这个整数以外，我们还输入了一个“回车”。是的，回车是scanf结束输入的标志，但回车却不会被scanf接收。这个回车虽然被输入了，但却游离在函数之外，直到gets函数出现了。 是的，gets函数直接接受了“回车”。更要命的是，gets函数也是以回车为输入结束的，这就导致gets函数出现了明显的异常。 解决方案: 在scanf和gets之间加入一个getchar来吸收这个回车就行了。 使用字符的库函数若是数组 12char a[10];strlen(a); //使用常量地址即可 若是指针 123char *p;p=(char *)malloc(sizeof(char)*10);strlen(p); //切记不能加*,取其首地址即可 以上使用错误会致使段错误，使得程序无法正常运行. memset使用实例 1234567void *memset(void *s, int c, size_t n); //原函数//整型之类的int a[4];memset(a,1,sizeof(a));//使a的全部元素全变为&#x27;1&#x27;//字符型类char a[20];memset(a,&#x27;o&#x27;,sizeof(a)); 二维数组传参123456789//有以下几种形式 #define N 20 void func(int (*a)[N])//N必须为 明确数字 第一维可省略 void func(int a[][N])//使用二维数组 *(*(a+i)+j) //i为行j为列 *(a[i]+j) *((int *)a+i*n+j)//此为万金油 结构体录入数据1234567typedef struct book&#123; char name[20]; float price;&#125;bk;bk bo[10];scanf(&quot;%f&quot;,&amp;bo[0].price);//必须加取地址符&amp; 而%s不用就很迷 自定义函数内结构体指针访问结构体数组1234567891011121314typedef struct student stu;struct student fun(struct student *std, char *num)&#123; int i; for(i=0;i&lt;8;i++,*std++) &#123; if(std-&gt;num[0]==*num) &#123; return *std; &#125; &#125; stu p=&#123;&quot;0&quot;,0,0&#125;; return p;&#125; 动态链表原函数特定结点删除，新增特定元素的结点12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct ListNode &#123; int data; struct ListNode *next;&#125;;typedef struct ListNode ln;struct ListNode *readlist()//创建 &#123; ln *head=NULL,*p1,*p2; int n=0; p1=p2=(ln*)malloc(sizeof(ln)); scanf(&quot;%d&quot;,&amp;p1-&gt;data); while(p1-&gt;data!=-1) &#123; n++; if(n==1) head=p1; else p2-&gt;next=p1; p2=p1; p1=(ln*)malloc(sizeof(ln)); scanf(&quot;%d&quot;,&amp;p1-&gt;data); &#125; p2-&gt;next=NULL; return head;&#125;struct ListNode *getodd( struct ListNode **L )&#123; ln *head=NULL,*p1,*p2,*p3,*p4; int n=0,i; p2=p3=(ln*)malloc(sizeof(ln)); for(p1=*L,i=0;p1!=NULL;p1=p1-&gt;next,i++) &#123; if(p1-&gt;data%2!=0)//将奇数录入新链表 &#123; n++; if(n==1) head=p2; else p3-&gt;next=p2; p2-&gt;data=p1-&gt;data; p3=p2; p2=(ln*)malloc(sizeof(ln)); &#125; if(p1-&gt;data%2!=0)//删除旧链表的奇数 &#123; if(i==0) &#123; *L=p1-&gt;next;i--;//i--尤为重要 &#125; else &#123; p4-&gt;next=p1-&gt;next; &#125; &#125; p4=p1;// printf(&quot;%d\\n&quot;,p1-&gt;data); &#125; p3-&gt;next=NULL; return head;&#125;void printlist( struct ListNode *L )&#123; struct ListNode *p = L; while (p) &#123; printf(&quot;%d &quot;, p-&gt;data); p = p-&gt;next; &#125; printf(&quot;\\n&quot;);&#125;int main()&#123; struct ListNode *L, *Odd; L = readlist(); Odd = getodd(&amp;L); printlist(Odd); printlist(L); return 0;&#125; 自定义函数动态链表结构体内元素的数组访问12345678910typedef struct student&#123; int num[20]; struct student *next;&#125;stu;stu* fun()&#123; stu p; &#125; 动态链表判断结束细节12345678910111213141516struct stud_node &#123; int num; char name[20]; int score; struct stud_node *next;&#125;;输入/*1 zhang 782 wang 803 li 754 zhao 850*/可以看到以num为0为特定动态链表结束的判断 1234567891011121314151617181920212223typedef struct stud_node stu;struct stud_node *createlist()&#123; stu *head=NULL,*p1,*p2; p1=p2=(stu*)malloc(sizeof(stu)); int n=0; scanf(&quot;%d&quot;,&amp;p1-&gt;num);//细节 if(p1-&gt;num==0) return NULL;//细节 scanf(&quot;%s%d&quot;,p1-&gt;name,&amp;p1-&gt;score); while(p1-&gt;num!=0) &#123; n++; if(n==1) head=p1; else p2-&gt;next=p1; p2=p1; p1=(stu*)malloc(sizeof(stu)); scanf(&quot;%d&quot;,&amp;p1-&gt;num);//细节 if(p1-&gt;num==0)break;//细节 scanf(&quot;%s%d&quot;,p1-&gt;name,&amp;p1-&gt;score); &#125; p2-&gt;next=NULL; return head;&#125; fgets123//原型#include &lt;stdio.h&gt;char *fgets(char *s, int size, FILE *stream); fgets()有三个参数。它的功能是从 stream 流中读取 size 个字符存储到字符指针变量 s 所指向的内存空间。它的返回值是一个指针，指向字符串中第一个字符的地址。 s 代表要保存到的内存空间的首地址，可以是字符数组名，也可以是指向字符数组的字符指针变量名。size 代表的是读取字符串的长度。stream 表示从何种流中读取，可以是标准输入流 stdin，也可以是文件流. fputs123//原型#include &lt;stdio.h&gt;int fputs(const char *s, FILE *stream); s 代表要输出的字符串的首地址，可以是字符数组名或字符指针变量名。 stream 表示向何种流中输出，可以是标准输出流 stdout，也可以是文件流。标准输出流即屏幕输出，printf 其实也是向标准输出流中输出的。 fputs() 和 puts() 有两个小区别：1.puts() 只能向标准输出流输出，而 fputs() 可以向任何流输出。2.使用 puts() 时，系统会在自动在其后添加换行符；而使用 fputs() 时，系统不会自动添加换行符。 那么这是不是意味着使用 fputs() 时就要在后面添加一句“printf(“\\n”)；”换行呢？看情况！如果输入时使用的是 gets()，那么就要添加 printf 换行；但如果输入时用的是 fgets()，则不需要。","categories":[],"tags":[{"name":"c语言 error","slug":"c语言-error","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-error/"}]},{"title":"蓝桥杯","slug":"蓝桥杯","date":"2022-11-19T09:29:49.000Z","updated":"2022-11-26T07:00:17.422Z","comments":true,"path":"2022/11/19/蓝桥杯/","link":"","permalink":"http://midsummer.github.io.com/2022/11/19/%E8%93%9D%E6%A1%A5%E6%9D%AF/","excerpt":"","text":"","categories":[],"tags":[{"name":"c语言 竞赛","slug":"c语言-竞赛","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E7%AB%9E%E8%B5%9B/"}]},{"title":"pointers","slug":"pointers","date":"2022-11-17T03:46:18.000Z","updated":"2022-11-20T08:08:27.793Z","comments":true,"path":"2022/11/17/pointers/","link":"","permalink":"http://midsummer.github.io.com/2022/11/17/pointers/","excerpt":"##字符串的排序 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; int n,i,j; scanf(&quot;%d&quot;,&amp;n); char *p[n+1],t[80]; for(i=0;i&lt;n+1;i++) &#123; p[i]=(char*)malloc(sizeof(char)*80); gets(p[i]); &#125; for(i=0;i&lt;n+1;i++) for(j=i+1;j&lt;n+1;j++) if(strcmp(p[i],p[j])&lt;0) &#123; strcpy(t,p[i]); strcpy(p[i],p[j]); strcpy(p[j],t); &#125; putchar(&#x27;\\n&#x27;); for(i=0;i&lt;n+1;i++) puts(p[i]); return 0;&#125;","text":"##字符串的排序 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123; int n,i,j; scanf(&quot;%d&quot;,&amp;n); char *p[n+1],t[80]; for(i=0;i&lt;n+1;i++) &#123; p[i]=(char*)malloc(sizeof(char)*80); gets(p[i]); &#125; for(i=0;i&lt;n+1;i++) for(j=i+1;j&lt;n+1;j++) if(strcmp(p[i],p[j])&lt;0) &#123; strcpy(t,p[i]); strcpy(p[i],p[j]); strcpy(p[j],t); &#125; putchar(&#x27;\\n&#x27;); for(i=0;i&lt;n+1;i++) puts(p[i]); return 0;&#125; ##Notes 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394注意printf(&quot;%s&quot;,*p) p为一个指针 p=str (int str[4]) 使p指针指向str*(p+i)=score 使str[i]值==score int *p,a[10],i; p=a;*(p+i) = a[i] = *(a+i)p : 代表指向值的地址 *p: 代表指向的值 -----改变可直接改变指向的值 &amp;p: 代表指针的地址 int a[10]p不动遍历数组for(i=0;i&lt;10;i++) printf(&quot;%d&quot;,*(p+i));p移动遍历数组for(p=a;p&lt;a+10;p++) printf(&quot;%d&quot;,*p); // p指针用完要复位 指针和二维数组int a[3][3] int *p;p=a;*a: 数组首地址0行0列*(a+1): 第1行0列的 **地址** *a+1: 第0行1列 **地址** *(a+2)+2: 第2行2列 **地址** -----i行j列的 **地址** = *(a+i)+j i行j列的值 = *(*(a+i)+j) 分配空间int *p;int i;p=(int *)malloc(sizeof(int)*10); // 申请10个int内存 for(i=0;i&lt;10;i++)&#123; scanf(&quot;%d&quot;,p+i);&#125;for(i=0;i&lt;10;i++)&#123; printf(&quot;%d&quot;,*(p+i))&#125;注意 以下p是函数名 返回指针的函数&#123; int *p(int a,int b) 指向什么类型的指针前缀用什么类型； return 指针; &#125;指向函数的指针&#123; 初始 int(*p)(int a,int b) 调用 result=(*p)(a,b) 函数名作为参数 &#123; int sum(int a,int b)也是一个子函数 void coun(int(*p)(int,int),int a,int b)也是子函数 用法 count(sum,a,b) 然后进入coun函数内此时*p指向的是sum &#125; &#125;指针数组(适合用来处理字符串)&#123; 不要与行指针相混淆--int (*p)[4] 类型名*数组名【数组长度】 int *p[n] 存放n个指向整型的指针;定义要用=&#123;&amp;a,&amp;b等等&#125; &#125;多重指针（一般不超过2层）&#123; int a=10; int *p1=&amp;a; int **p2=&amp;p1; &#125; 带参数的main函数&#123; 没看懂。 &#125;","categories":[],"tags":[{"name":"c语言 指针","slug":"c语言-指针","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88/"}]},{"title":"Solidity","slug":"Solidity","date":"2022-11-16T05:56:09.000Z","updated":"2022-12-20T09:25:41.236Z","comments":true,"path":"2022/11/16/Solidity/","link":"","permalink":"http://midsummer.github.io.com/2022/11/16/Solidity/","excerpt":"Solidity学习笔记 这篇Blog我会持续update 这是本人第一篇blog，我真的非常开心能够拥有自己的blog，不说废话了，开始学习. [toc]","text":"Solidity学习笔记 这篇Blog我会持续update 这是本人第一篇blog，我真的非常开心能够拥有自己的blog，不说废话了，开始学习. [toc] Solidity基础先温习之前学过了的内容 变量类型 数值类型 布尔型 12//初始化bool public _bool = true;//or false 初始值是false 运算符号 有 与&amp;&amp; 非 ! 或|| 等于 == 不等于!= 均遵循数学逻辑. 整型 123int //整数uint //正整数uint256 //256位正整数 运算包括 +加 -减 *乘 /除 %求余 **幂 比较大小 枚举 这个太冷门不做总结 地址 1address public _address1 //初始值为0x0000000000000 定长字节数组 1byte public _byte //固定长度的字节数组 注意若定义数组为uint 若不定义第一个元素的类型则固定为最小类型 函数类型 pure 不能读取也不能写入储存在链上的状态变量 view 能读取但不能写入状态变量 特点：都不消耗gas internal 只能由合约内部调用，而合约外部不能 external 合约外部可以调用，但合约内部不行 payable 递钱，能给合约支付eth的函数 函数输出 return 用于函数主体，返回指定的变量 returns 加在函数名后面，声明返回的变量类型和变量名 命名式返回和解构式赋值 可以在returns中表明返回类型的名称，这样不需要加return 都可以自动初始化变量并返回对应变量的值 支持返回全部或部分返回值 1234uint256 _number;bool _bool;uint256[3] memory _array;(_number, _bool, _array) = returnNamed(); 1(, _bool2, ) = returnNamed(); 变量数据储存和作用域引用类型和数据位置数组，结构体，映射，在使用时候必须声明出储存位置 storage 状态变量默认都是storage，储存在链上 memory 参数和临时变量一般用这个，储存在内存，不上链 calldata 储存在内存，不上链，特点定义后不能修改 赋值规则 storage赋值给storage时会创建引用，修改其中一个值，会改变另外一个引用的或被引用的值 storage赋值给memory,互不影响 变量的作用域Gas消耗量 状态变量 &gt; 局部变量 全局变量 blockhash(uint blockNumber): (bytes32)给定区块的哈希值 – 只适用于256最近区块, 不包含当前区块。 block.coinbase: (address payable) 当前区块矿工的地址 block.gaslimit: (uint) 当前区块的gaslimit block.number: (uint) 当前区块的number block.timestamp: (uint) 当前区块的时间戳，为unix纪元以来的秒 gasleft(): (uint256) 剩余 gas msg.data: (bytes calldata) 完整call data msg.sender: (address payable) 消息发送者 (当前 caller) msg.sig: (bytes4) calldata的前四个字节 (function identifier) msg.value: (uint) 当前交易发送的wei值 引用类型数组12345678uint[8] array1; //初始化 固定数组bytes1[5] array2;address[100] array3;uint[] array4; //可变长度 bytes1[] array5;address[] array6;bytes array7; 动态数组，需要一个一个元素的赋值 对于memory修饰的动态数组，可以用new操作符来创建，但是必须声明长度，并且声明后长度不能改变 数组成员 length: 数组有一个包含元素数量的length成员，memory数组的长度在创建后是固定的。 push(): 动态数组和bytes拥有push()成员，可以在数组最后添加一个0元素。 push(x): 动态数组和bytes拥有push(x)成员，可以在数组最后添加一个x元素。 pop(): 动态数组和bytes拥有pop()成员，可以移除数组最后一个元素。 结构体相当于定义一个新的类型 12345678910111213141516171819202122232425 // 结构体 struct Student&#123; uint256 id; uint256 score; &#125; Student student; // 初始一个student结构体 // 给结构体赋值// 方法1:在函数中创建一个storage的struct引用,利用storage to storage 的引用间接赋值 function initStudent1() external&#123; Student storage _student = student; // assign a copy of student _student.id = 11; _student.score = 100; &#125; // 方法2:直接引用状态变量的struct function initStudent2() external&#123; student.id = 1; student.score = 80; &#125; 映射使用键(key) &#x3D;&gt; 值(value) 声明映射的格式为mapping(_KeyType =&gt; _ValueType)，其中_KeyType和_ValueType分别是Key和Value的变量类型。 1234//初始化mapping(uint =&gt; address) pubilc idToAddress //使用id 可查询地址mapping(address =&gt; address) pubilic swappair //地址对应地址idToAddress[214134] = 0x00000000 //为idtoaddress新增键值对 Rule 映射的_KeyType只能选择solidity默认的类型，比如uint，address等，不能用自定义的结构体。而_ValueType可以使用自定义的类型。 映射的存储位置必须是storage，因此可以用于合约的状态变量，函数中的storage变量，和library函数的参数（见例子）。不能用于public函数的参数或返回结果中，因为mapping记录的是一种关系 (key - value pair)。 如果映射声明为public，那么solidity会自动给你创建一个getter函数，可以通过Key来查询对应的Value。 给映射新增的键值对的语法为_Var[_Key] = _Value，其中_Var是映射变量名，_Key和_Value对应新增的键值对 原理 映射不储存任何键（Key）的资讯，也没有length的资讯。 映射使用keccak256(key)当成offset存取value。 因为Ethereum会定义所有未使用的空间为0，所以未赋值（Value）的键（Key）初始值都是0。 变量初始值值类型初始值 boolean: false string: &quot;&quot; int: 0 uint: 0 enum: 枚举中的第一个元素 address: 0x0000000000000000000000000000000000000000 (或 address(0)) &#96;&#96;&#96;function 1234567891011121314151617181920212223242526 - `internal`: 空白方程 - `external`: 空白方程#### 引用类型初始值- 映射`mapping`: 所有元素都为其默认值的`mapping`- 结构体`struct`: 所有成员设为其默认值的结构体- 数组`array` - 动态数组: `[]` - 静态数组（定长）: 所有成员设为其默认值的静态数组#### delete`delete a`会让变量`a`的值变为初始值。### 常数&gt; 只有数值变量可以声明`constant`和`immutable`；`string`和`bytes`可以声明为`constant`，但不能为`immutable`。#### constant必须在声明的时候便初始化,之后再也改变不了```solidityuint256 constant CONSTANT_NUM = 10; //初始化 immutable可以在声明时，或者在构造函数,自定义函数中初始化，之后再也不能改变 12345678910uint public immutable A = 999;uint public immutable B;uint public immutable C;constructor()&#123; //构造函数 B = 999;&#125;B = putin();function putin(uint256 d) external pure returns(uint256)&#123; //自定义函数 return(d);&#125; 控制流Solidity的控制流与其他语言类似，主要包含以下几种： if-else 1234567function ifElseTest(uint256 _number) public pure returns(bool)&#123; if(_number == 0)&#123; return(true); &#125;else&#123; return(false); &#125;&#125; for循环 1234567function forLoopTest() public pure returns(uint256)&#123; uint sum = 0; for(uint i = 0; i &lt; 10; i++)&#123; sum += i; &#125; return(sum);&#125; while循环 123456789function whileTest() public pure returns(uint256)&#123; uint sum = 0; uint i = 0; while(i &lt; 10)&#123; sum += i; i++; &#125; return(sum);&#125; do-while循环 123456789function doWhileTest() public pure returns(uint256)&#123; uint sum = 0; uint i = 0; do&#123; sum += i; i++; &#125;while(i &lt; 10); return(sum);&#125; 三元运算符 三元运算符是solidity中唯一一个接受三个操作数的运算符，规则条件? 条件为真的表达式:条件为假的表达式。 此运算符经常用作 if 语句的快捷方式。 12345// 三元运算符 ternary/conditional operatorfunction ternaryTest(uint256 x, uint256 y) public pure returns(uint256)&#123; // return the max of x and y return x &gt;= y ? x: y; &#125; 另外还有continue（立即进入下一个循环）和break（跳出当前循环）关键字可以使用。 构造函数和修饰器构造函数一种特殊函数，每个合约仅有一个，并且只在部署合约时运行一次。用来初始化合约的一些参数. 123456address owner; // 定义owner变量// 构造函数constructor() &#123; owner = msg.sender; // 在部署合约的时候，将owner设置为部署者的地址&#125; 修饰器修饰器（modifier）是solidity特有的语法，类似于面向对象编程中的decorator，声明函数拥有的特性，并减少代码冗余。 12345// 定义modifier onlyowner &#123; require(msg.sender == owner);// 检查调用者是否为owner地址 _;// 如果是的话，继续运行函数主体；否则报错并revert交易&#125; 事件Solidity中的事件（event）是EVM上日志的抽象，它具有两个特点： 响应：应用程序（ether.js）可以通过RPC接口订阅和监听这些事件，并在前端做响应。 经济：事件是EVM上比较经济的存储数据的方式，每个大概消耗2,000 gas；相比之下，链上存储一个新变量至少需要20,000 gas. 12//定义event Transfer(address indexed from, address indexed to, uint256 value); 事件的声明由event关键字开头，然后跟事件名称，括号里面写好事件需要记录的变量类型和变量名。使用emit可以释放事件. indexed标记的变量可以理解为检索事件的索引“键”，在以太坊上单独作为一个topic进行存储和索引，程序可以轻松的筛选出特定转账地址和接收地址的转账事件。每个事件最多有3个带indexed的变量。每个 indexed 变量的大小为固定的256比特。事件的哈希以及这三个带indexed的变量在EVM日志中通常被存储为topic。其中topic[0]是此事件的keccak256哈希，topic[1]到topic[3]存储了带indexed变量的keccak256哈希。 123456789101112131415// 定义_transfer函数，执行转账逻辑function _transfer( address from, address to, uint256 amount) external &#123; _balances[from] = 10000000; // 给转账地址一些初始代币 _balances[from] -= amount; // from地址减去转账数量 _balances[to] += amount; // to地址加上转账数量 // 释放事件 emit Transfer(from, to, amount);&#125; 继承函数的继承规则 virtual: 父合约中的函数，如果希望子合约重写，需要加上virtual关键字。 override：子合约重写了父合约中的函数，需要加上override关键字。 12345678910111213141516contract A &#123;function XXX() virtual &#123;....&#125;.......&#125;contract B is A&#123;function XXX() virtual override &#123;....&#125;.......&#125;contract C is A, B&#123;function XXX() override(A, B) // 重写在多个父合约中都重名的函数时，override关键字后面要加上所有父合约的名字.......&#125; 修饰器的继承Solidity中的修饰器（Modifier）同样可以继承，用法与函数继承类似，在相应的地方加virtual和override关键字即可。 123456789101112131415161718192021contract Base1 &#123; modifier exactDividedBy2And3(uint _a) virtual &#123; require(_a % 2 == 0 &amp;&amp; _a % 3 == 0); _; &#125;&#125;contract Identifier is Base1 &#123; //计算一个数分别被2除和被3除的值，但是传入的参数必须是2和3的倍数 function getExactDividedBy2And3(uint _dividend) public exactDividedBy2And3(_dividend) pure returns(uint, uint) &#123; return getExactDividedBy2And3WithoutModifier(_dividend); &#125; //计算一个数分别被2除和被3除的值 function getExactDividedBy2And3WithoutModifier(uint _dividend) public pure returns(uint, uint)&#123; uint div2 = _dividend / 2; uint div3 = _dividend / 3; return (div2, div3); &#125;&#125; 直接引用或者重写 1234modifier exactDividedBy2And3(uint _a) override &#123; _; require(_a % 2 == 0 &amp;&amp; _a % 3 == 0);&#125; 构造函数的继承子合约有两种方法继承父合约的构造函数。举个简单的例子，父合约A里面有一个状态变量a，并由构造函数的参数来确定： 12345678// 构造函数的继承abstract contract A &#123; uint public a; constructor(uint _a) &#123; a = _a; &#125;&#125; 在继承时声明父构造函数的参数，例如：contract B is A(1) 在子合约的构造函数中声明构造函数的参数，例如： 123contract C is A &#123; constructor(uint _c) A(_c * _c) &#123;&#125;&#125; 调用父合约的函数 直接调用：子合约可以直接用父合约名.函数名()的方式来调用父合约函数. 123function F() public&#123; A.XXX();&#125; super关键字,子合约可以利用super.函数名()来调用最近的父合约函数。 123function G() public&#123; super.XXX();&#125; 抽象合约如果一个智能合约里至少有一个未实现的函数，即某个函数缺少主体&#123;&#125;中的内容，则必须将该合约标为abstract，不然编译会报错；另外，未实现的函数需要加virtual，以便子合约重写。拿我们之前的插入排序合约为例，如果我们还没想好具体怎么实现插入排序函数，那么可以把合约标为abstract，之后让别人补写上。 123abstract contract H&#123;....&#125; 异常errorerror是solidity 0.8版本新加的内容，方便且高效（省gas）地向用户解释操作失败的原因。人们可以在contract之外定义异常。 搭配revert使用 1234567error TransferNotOwner(); // 自定义error function transferOwner1(uint256 tokenId, address newOwner) public &#123; if(_owners[tokenId] != msg.sender)&#123; revert TransferNotOwner(); &#125; _owners[tokenId] = newOwner; &#125;//我们定义了一个transferOwner1()函数，它会检查代币的owner是不是发起人，如果不是，就会抛出TransferNotOwner异常；如果是的话，就会转账。 requirerequire命令是solidity 0.8版本之前抛出异常的常用方法，目前很多主流合约仍然还在使用它。它很好用，唯一的缺点就是gas随着描述异常的字符串长度增加，比error命令要高。使用方法：require(检查条件，&quot;异常的描述&quot;)，当检查条件不成立的时候，就会抛出异常。 1234function transferOwner2(uint256 tokenId, address newOwner) public &#123; require(_owners[tokenId] == msg.sender, &quot;Transfer Not Owner&quot;); _owners[tokenId] = newOwner;&#125; assertassert命令一般用于程序员写程序debug，因为它不能解释抛出异常的原因（比require少个字符串）。它的用法很简单，assert(检查条件），当检查条件不成立的时候，就会抛出异常。 1234function transferOwner3(uint256 tokenId, address newOwner) public &#123; assert(_owners[tokenId] == msg.sender); _owners[tokenId] = newOwner;&#125; Gas使用量 error &lt; assert &lt; require Solidity进阶函数重载即名字相同但输入参数类型不同的函数可以同时存在，他们被视为不同的函数。 修饰器不允许重载 1234567//例子function say() public pure returns(string memory)&#123; return(&quot;Fuck&quot;);&#125;function say(string memory words) public pure returns(string memory)&#123; return(words);&#125; 实参匹配在调用重载函数时，会把输入的实际参数和函数参数的变量类型做匹配。 如果出现多个匹配的重载函数，则会报错。如以下——我们调用f(50)，因为50既可以被转换为uint8，也可以被转换为uint256，因此会报错。 1234567function f(uint8 _in) public pure returns (uint8 out) &#123; out = _in;&#125;function f(uint256 _in) public pure returns (uint256 out) &#123; out = _in;&#125; 库函数 站在巨人的肩膀上(提升solidity代码的复用性和减少gas而存在)——-由大神或者项目方创作 不能存在状态变量 不能够被继承或被继承 不能接受ETH 不可以被销毁 例子 1234library strings &#123;..............//内容省略&#125;//库函数strings//他主要包含两个函数，toString()将uint256转为string，toHexString()将uint256转换为16进制，在转换为string。 使用库函数 using A for B 指令using A for B;可用于附加库函数（从库 A）到任何类型（B）。添加完指令后，库A中的函数会自动添加为B类型变量的成员，可以直接调用。 注意：在调用的时候，这个变量会被当作第一个参数传递给函数： 123456// 利用using for指令using Strings for uint256;function getString1(uint256 _number) public pure returns(string memory)&#123;// 库函数会自动添加为uint256型变量的成员 return _number.toHexString();&#125; 通过库合约名称调用库函数 1234// 直接通过库合约名调用function getString2(uint256 _number) public pure returns(string memory)&#123; return Strings.toHexString(_number);&#125; 几种常用库函数 String：将uint256转换为String Address：判断某个地址是否为合约地址 Create2：更安全的使用Create2 EVM opcode Arrays：跟数组相关的库函数 import solidity支持利用import关键字导入其他源代码中的合约，让开发更加模块化。 相对位置导入 例如：当strom.sol 和 jean.sol在同一目录下时 1improt &#x27;./jean.sol&#x27;; 通过源文件网址导入网上的合约 12// 通过网址引用import &#x27;https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol&#x27;; 通过npm目录导入 1import &#x27;@openzeppelin/contracts/access/Ownable.sol&#x27;; 通过全局符号导入特定合约 1import &#123;Yeye&#125; from &#x27;./Yeye.sol&#x27;; 引用(import)在代码中的位置为：在声明版本号之后，在其余代码之前 接受ETH和fallback回调receive()和fallback()，他们主要在两种情况下被使用： 接收ETH 处理合约中不存在的函数调用（代理合约proxy contract） 在solidity 0.6.x版本之前，语法上只有 fallback() 函数，用来接收用户发送的ETH时调用以及在被调用函数签名没有匹配到时，来调用。 0.6版本之后，solidity才将 fallback() 函数拆分成 receive() 和 fallback() 两个函数。 receivereceive()只用于处理接收ETH。一个合约最多有一个receive()函数，声明方式与一般函数不一样，不需要function关键字：receive() external payable &#123; ... &#125;。receive()函数不能有任何的参数，不能返回任何值，必须包含external和payable。 1234event received(address sender, uint value);receive() external payable &#123;emit received(msg.sender, msg.value);&#125; fallbackfallback()函数会在调用合约不存在的函数时被触发。可用于接收ETH，也可以用于代理合约proxy contract。fallback()声明时不需要function关键字，必须由external修饰，一般也会用payable修饰，用于接收ETH:fallback() external payable &#123; ... &#125;。 1234// fallbackfallback() external payable&#123; emit fallbackCalled(msg.sender, msg.value, msg.data);&#125; 差别触发规则123456789101112触发fallback() 还是 receive()? 接收ETH | msg.data是空？ / \\ 是 否 / \\receive()存在? fallback() / \\ 是 否 / \\receive() fallback() receive()和payable fallback()均不存在的时候，向合约发送ETH将会报错。 发送ETH Solidity有三种方法向其他合约发送ETH，他们是：transfer()，send()和call()，其中call()是被鼓励的用法。 1234567891011121314 contract ReceiveETH &#123; // 收到eth事件，记录amount和gas event Log(uint amount, uint gas); // receive方法，接收eth时被触发 receive() external payable&#123; emit Log(msg.value, gasleft()); &#125; // 返回合约ETH余额 function getBalance() view public returns(uint) &#123; return address(this).balance; &#125;&#125; transfer 用法是接收方地址.transfer(发送ETH数额)。 transfer()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。 transfer()如果转账失败，会自动revert（回滚交易）。 注意里面的_to填ReceiveETH合约的地址，amount是ETH转账金额： 1234// 用transfer()发送ETHfunction transferETH(address payable _to, uint256 amount) external payable&#123; _to.transfer(amount);&#125; send 用法是接收方地址.send(发送ETH数额)。 send()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。 send()如果转账失败，不会revert。 send()的返回值是bool，代表着转账成功或失败，需要额外代码处理一下。 12345678// send()发送ETHfunction sendETH(address payable _to, uint256 amount) external payable&#123; // 处理下send的返回值，如果失败，revert交易并发送error bool success = _to.send(amount); if(!success)&#123; revert SendFailed(); &#125;&#125; call 用法是接收方地址.call&#123;value: 发送ETH数额&#125;(&quot;&quot;)。 call()没有gas限制，可以支持对方合约fallback()或receive()函数实现复杂逻辑。 call()如果转账失败，不会revert。 call()的返回值是(bool, data)，其中bool代表着转账成功或失败，需要额外代码处理一下。 12345678// call()发送ETHfunction callETH(address payable _to, uint256 amount) external payable&#123; // 处理下call的返回值，如果失败，revert交易并发送error (bool success,) = _to.call&#123;value: amount&#125;(&quot;&quot;); if(!success)&#123; revert CallFailed(); &#125;&#125; call没有gas限制，最为灵活，是最提倡的方法； transfer有2300 gas限制，但是发送失败会自动revert交易，是次优选择； send有2300 gas限制，而且发送失败不会自动revert交易，几乎没有人用它。 调用其它合约我们可以利用合约的地址和合约代码（或接口）来创建合约的引用：_Name(_Address)，其中_Name是合约名，_Address是合约地址。然后用合约的引用来调用它的函数：_Name(_Address).f()，其中f()是要调用的函数。 传入合约地址 我们可以在函数里传入目标合约地址，生成目标合约的引用，然后调用目标函数。以调用OtherContract合约的setX函数为例，我们在新合约中写一个callSetX函数，传入已部署好的OtherContract合约地址_Address和setX的参数x： 123function callSetX(address _Address, uint256 x) external&#123; OtherContract(_Address).setX(x); &#125; 传入合约变量 我们可以直接在函数里传入合约的引用，只需要把上面参数的address类型改为目标合约名，比如OtherContract。下面例子实现了调用目标合约的getX()函数。 注意该函数参数OtherContract _Address底层类型仍然是address，生成的ABI中、调用callGetX时传入的参数都是address类型 123function callGetX(OtherContract _Address) external view returns(uint x)&#123; x = _Address.getX(); &#125; 创建合约变量 我们可以创建合约变量，然后通过它来调用目标函数。下面例子，我们给变量oc存储了OtherContract合约的引用： 1234function callGetX2(address _Address) external view returns(uint x)&#123; OtherContract oc = OtherContract(_Address); x = oc.getX(); &#125; 调用合约并发送ETH 如果目标合约的函数是payable的，那么我们可以通过调用它来给合约转账：_Name(_Address).f&#123;value: _Value&#125;()，其中_Name是合约名，_Address是合约地址，f是目标函数名，_Value是要转的ETH数额（以wei为单位）。 OtherContract合约的setX函数是payable的，在下面这个例子中我们通过调用setX来往目标合约转账。 123function setXTransferETH(address otherContract, uint256 x) payable external&#123; OtherContract(otherContract).setX&#123;value: msg.value&#125;(x); &#125; Callcall 是address类型的低级成员函数，它用来与其他合约交互。它的返回值为(bool, data)，分别对应call是否成功以及目标函数的返回值。 call是solidity官方推荐的通过触发fallback或receive函数发送ETH的方法。 不推荐用call来调用另一个合约，因为当你调用不安全合约的函数时，你就把主动权交给了它。推荐的方法仍是声明合约变量后调用函数. 当我们不知道对方合约的源代码或ABI，就没法生成合约变量；这时，我们仍可以通过call调用对方合约的函数。 rule call的使用规则如下： 1目标合约地址.call(二进制编码); 其中二进制编码利用结构化编码函数abi.encodeWithSignature获得： 1abi.encodeWithSignature(&quot;函数签名&quot;, 逗号分隔的具体参数) 函数签名为&quot;函数名（逗号分隔的参数类型)&quot;。例如abi.encodeWithSignature(&quot;f(uint256,address)&quot;, _x, _addr)。 另外call在调用合约时可以指定交易发送的ETH数额和gas： 1目标合约地址.call&#123;value:发送数额, gas:gas数额&#125;(二进制编码); 看起来有点复杂，下面我们举个call应用的例子。 利用call调用目标合约 Response事件 我们写一个Call合约来调用目标合约函数。首先定义一个Response事件，输出call返回的success和data，方便我们观察返回值。 &#x2F;&#x2F; 定义Response事件，输出call返回的结果success和dataevent Response(bool success, bytes data); 调用setX函数 我们定义callSetX函数来调用目标合约的setX()，转入msg.value数额的ETH，并释放Response事件输出success和data： function callSetX(address payable _addr, uint256 x) public payable { &#x2F;&#x2F; call setX()，同时可以发送ETH (bool success, bytes memory data) &#x3D; _addr.call{value: msg.value}( abi.encodeWithSignature(“setX(uint256)”, x) ); emit Response(success, data); //释放事件 } 接下来我们调用callSetX把状态变量_x改为5，参数为OtherContract地址和5，由于目标函数setX()没有返回值，因此Response事件输出的data为0x，也就是空。 调用getX函数 下面我们调用getX()函数，它将返回目标合约_x的值，类型为uint256。我们可以利用abi.decode来解码call的返回值data，并读出数值。 function callGetX(address _addr) external returns(uint256){ &#x2F;&#x2F; call getX() (bool success, bytes memory data) &#x3D; _addr.call( abi.encodeWithSignature(“getX()”) ); emit Response(success, data); //释放事件 return abi.decode(data, (uint256)); } 从Response事件的输出，我们可以看到data为0x0000000000000000000000000000000000000000000000000000000000000005。而经过abi.decode，最终返回值为5。 . 调用不存在的函数 如果我们给call输入的函数不存在于目标合约，那么目标合约的fallback函数会被触发。 function callNonExist(address _addr) external{ &#x2F;&#x2F; call getX() (bool success, bytes memory data) &#x3D; _addr.call( abi.encodeWithSignature(“foo(uint256)”) ); emit Response(success, data); //释放事件 } 上面例子中，我们call了不存在的foo函数。call仍能执行成功，并返回success，但其实调用的目标合约fallback函数。 Delegatecalldelegatecall与call类似，是solidity中地址类型的低级成员函数。delegate中是委托&#x2F;代表的意思，那么delegatecall委托了什么？ 当用户A通过合约B来call合约C的时候，执行的是合约C的函数，语境(Context，可以理解为包含变量和状态的环境)也是合约C的：msg.sender是B的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约C的变量上。 而当用户A通过合约B来delegatecall合约C的时候，执行的是合约C的函数，但是语境仍是合约B的：msg.sender是A的地址，并且如果函数改变一些状态变量，产生的效果会作用于合约B的变量上。 大家可以这样理解：一个富商把它的资产（状态变量）都交给一个VC代理（目标合约的函数）来打理。执行的是VC的函数，但是改变的是富商的状态。 delegatecall语法和call类似，也是： 目标合约地址.delegatecall(二进制编码); 其中二进制编码利用结构化编码函数abi.encodeWithSignature获得： abi.encodeWithSignature(“函数签名”, 逗号分隔的具体参数) 函数签名为”函数名（逗号分隔的参数类型)”。例如abi.encodeWithSignature(“f(uint256,address)”, _x, _addr)。 和call不一样，delegatecall在调用合约时可以指定交易发送的gas，但不能指定发送的ETH数额 注意：delegatecall有安全隐患，使用时要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。 目前delegatecall主要有两个应用场景： 代理合约（Proxy Contract）：将智能合约的存储合约和逻辑合约分开：代理合约（Proxy Contract）存储所有相关的变量，并且保存逻辑合约的地址；所有函数存在逻辑合约（Logic Contract）里，通过delegatecall执行。当升级时，只需要将代理合约指向新的逻辑合约即可。 EIP-2535 Diamonds（钻石）：钻石是一个支持构建可在生产中扩展的模块化智能合约系统的标准。钻石是具有多个实施合同的代理合同。 更多信息请查看：钻石标准简介。 在合约中创建新合约create和create2 有两种方法可以在合约中创建新合约，create和create2，这里我们讲create，下一讲会介绍create2。 create的用法很简单，就是new一个合约，并传入新合约构造函数所需的参数： Contract x &#x3D; new Contract{value: _value}(params) 其中Contract是要创建的合约名，x是合约对象（地址），如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。 极简uniswap Uniswap V2核心合约中包含两个合约： UniswapV2Pair: 币对合约，用于管理币对地址、流动性、买卖。 UniswapV2Factory: 工厂合约，用于创建新的币对，并管理币对地址。 下面我们用create方法实现一个极简版的Uniswap：Pair币对合约负责管理币对地址，PairFactory工厂合约用于创建新的币对，并管理币对地址。 Create2CREATE2 CREATE2 操作码使我们在智能合约部署在以太坊网络之前就能预测合约的地址。Uniswap创建Pair合约用的就是CREATE2而不是CREATE。这一讲，我将介绍CREATE2的用法 CREATE如何计算地址 智能合约可以由其他合约和普通账户利用CREATE操作码创建。 在这两种情况下，新合约的地址都以相同的方式计算：创建者的地址(通常为部署的钱包地址或者合约地址)和nonce(该地址发送交易的总数,对于合约账户是创建的合约总数,每创建一个合约nonce+1))的哈希。 1新地址 = hash(创建者地址, nonce) 创建者地址不会变，但nonce可能会随时间而改变，因此用CREATE创建的合约地址不好预测。 CREATE2如何计算地址 CREATE2的目的是为了让合约地址独立于未来的事件。不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上。用CREATE2创建的合约地址由4个部分决定： 0xFF：一个常数，避免和CREATE冲突 创建者地址 salt（盐）：一个创建者给定的数值 待部署合约的字节码（bytecode） 1新地址 = hash(&quot;0xFF&quot;,创建者地址, salt, bytecode) CREATE2 确保，如果创建者使用 CREATE2 和提供的 salt 部署给定的合约bytecode，它将存储在 新地址 中。 如何使用CREATE2 CREATE2的用法和之前讲的Create类似，同样是new一个合约，并传入新合约构造函数所需的参数，只不过要多传一个salt参数： 1Contract x = new Contract&#123;salt: _salt, value: _value&#125;(params) 其中Contract是要创建的合约名，x是合约对象（地址），_salt是指定的盐；如果构造函数是payable，可以创建时转入_value数量的ETH，params是新合约构造函数的参数。 selfdestructselfdestruct使用起来非常简单： selfdestruct(_addr)； 其中_addr是接收合约中剩余ETH的地址。 1234567891011121314151617contract DeleteContract &#123; uint public value = 10; constructor() payable &#123;&#125; receive() external payable &#123;&#125; function deleteContract() external &#123; // 调用selfdestruct销毁合约，并把剩余的ETH转给msg.sender selfdestruct(payable(msg.sender)); &#125; function getBalance() external view returns(uint balance)&#123; balance = address(this).balance; &#125;&#125; 在DeleteContract合约中，我们写了一个public状态变量value，两个函数：getBalance()用于获取合约ETH余额，deleteContract()用于自毁合约，并把ETH转入给发起人。 部署好合约后，我们向DeleteContract合约转入1 ETH。这时，getBalance()会返回1 ETH，value变量是10。 当我们调用deleteContract()函数，合约将自毁，所有变量都清空，此时value变为默认值0，getBalance()也返回空值。 对外提供合约销毁接口时，最好设置为只有合约所有者可以调用，可以使用函数修饰符onlyOwner进行函数声明。 当合约被销毁后与智能合约的交互也能成功，并且返回0。 当合约中有selfdestruct功能时常常会带来安全问题和信任问题，合约中的Selfdestruct功能会为攻击者打开攻击向量(例如使用selfdestruct向一个合约频繁转入token进行攻击，这将大大节省了GAS的费用，虽然很少人这么做)，此外，此功能还会降低用户对合约的信心。 ABI编码我们将用编码4个变量，他们的类型分别是uint256, address, string, uint256[2]： uint x = 10; address addr = 0x7A58c0Be72BE218B41C608b7Fe7C5bB630736C71; string name = &quot;0xAA&quot;; uint[2] array = [5, 6]; abi.encode 将给定参数利用ABI规则编码。ABI被设计出来跟智能合约交互，他将每个参数填充为32字节的数据，并拼接在一起。如果你要和合约交互，你要用的就是abi.encode。 function encode() public view returns(bytes memory result) &#123; result = abi.encode(x, addr, name, array); &#125; 编码的结果为0x000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000007a58c0be72be218b41c608b7fe7c5bb630736c7100000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000043078414100000000000000000000000000000000000000000000000000000000，由于abi.encode将每个数据都填充为32字节，中间有很多0。 selector当我们调用智能合约时，本质上是向目标合约发送了一段calldata，在remix中发送一次交易后，可以在详细信息中看见input即为此次交易的calldata msg.data msg.data是solidity中的一个全局变量，值为完整的calldata（调用函数时传入的数据）。 在下面的代码中，我们可以通过Log事件来输出调用mint函数的calldata： 123456// event 返回msg.dataevent Log(bytes data);function mint(address to) external&#123; emit Log(msg.data);&#125; 当参数为0x2c44b726ADF1963cA47Af88B284C06f30380fC78时，输出的calldata为 10x6a6278420000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78 这段很乱的字节码可以分成两部分： 12345前4个字节为函数选择器selector：0x6a627842后面32个字节为输入的参数：0x0000000000000000000000002c44b726adf1963ca47af88b284c06f30380fc78 其实calldata就是告诉智能合约，我要调用哪个函数，以及参数是什么。 method id, selector和函数签名 method id定义为函数签名的Keccak哈希后的前4个字节，当selector与method id相匹配时，即表示调用该函数，那么函数签名是什么？ 其实在第21讲中，我们简单介绍了函数签名，为”函数名（逗号分隔的参数类型)”。举个例子，上面代码中mint的函数签名为”mint(address)”。在同一个智能合约中，不同的函数有不同的函数签名，因此我们可以通过函数签名来确定要调用哪个函数。 注意，在函数签名中，uint和int要写为uint256和int256。 我们写一个函数，来验证mint函数的method id是否为0x6a627842。大家可以运行下面的函数，看看结果。 function mintSelector() external pure returns(bytes4 mSelector)&#123; return bytes4(keccak256(&quot;mint(address)&quot;)); &#125; 结果正是0x6a627842 使用selector 我们可以利用selector来调用目标函数。例如我想调用mint函数，我只需要利用abi.encodeWithSelector将mint函数的method id作为selector和参数打包编码，传给call函数： 1234function callWithSignature() external returns(bool, bytes memory)&#123; (bool success, bytes memory data) = address(this).call(abi.encodeWithSelector(0x6a627842, &quot;0x2c44b726ADF1963cA47Af88B284C06f30380fC78&quot;)); return(success, data);&#125; try-catch在solidity中，try-catch只能被用于external函数或创建合约时constructor（被视为external函数）的调用。基本语法如下： try externalContract.f() &#123; // call成功的情况下 运行一些代码 &#125; catch &#123; // call失败的情况下 运行一些代码 &#125; 其中externalContract.f()是某个外部合约的函数调用，try模块在调用成功的情况下运行，而catch模块则在调用失败时运行。 同样可以使用this.f()来替代externalContract.f()，this.f()也被视作为外部调用，但不可在构造函数中使用，因为此时合约还未创建。 如果调用的函数有返回值，那么必须在try之后声明returns(returnType val)，并且在try模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。 try externalContract.f() returns(returnType val)&#123; // call成功的情况下 运行一些代码 &#125; catch &#123; // call失败的情况下 运行一些代码 &#125; 另外，catch模块支持捕获特殊的异常原因： try externalContract.f() returns(returnType)&#123; // call成功的情况下 运行一些代码 &#125; catch Error(string memory reason) &#123; // 捕获失败的 revert() 和 require() &#125; catch (bytes memory reason) &#123; // 捕获失败的 assert() &#125;","categories":[],"tags":[{"name":"solidity smartcontract","slug":"solidity-smartcontract","permalink":"http://midsummer.github.io.com/tags/solidity-smartcontract/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-11-14T11:46:17.891Z","updated":"2022-11-20T08:10:44.649Z","comments":true,"path":"2022/11/14/hello-world/","link":"","permalink":"http://midsummer.github.io.com/2022/11/14/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"android","slug":"android","permalink":"http://midsummer.github.io.com/tags/android/"},{"name":"solidity","slug":"solidity","permalink":"http://midsummer.github.io.com/tags/solidity/"},{"name":"c语言 文件操作","slug":"c语言-文件操作","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"name":"c语言","slug":"c语言","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"c语言 结构体 链表","slug":"c语言-结构体-链表","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E7%BB%93%E6%9E%84%E4%BD%93-%E9%93%BE%E8%A1%A8/"},{"name":"c语言 error","slug":"c语言-error","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-error/"},{"name":"c语言 竞赛","slug":"c语言-竞赛","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E7%AB%9E%E8%B5%9B/"},{"name":"c语言 指针","slug":"c语言-指针","permalink":"http://midsummer.github.io.com/tags/c%E8%AF%AD%E8%A8%80-%E6%8C%87%E9%92%88/"},{"name":"solidity smartcontract","slug":"solidity-smartcontract","permalink":"http://midsummer.github.io.com/tags/solidity-smartcontract/"}]}